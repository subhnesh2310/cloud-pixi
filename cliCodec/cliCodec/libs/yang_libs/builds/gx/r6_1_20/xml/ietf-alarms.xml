<?xml version="1.0" encoding="UTF-8"?>
<module name="ietf-alarms"
        xmlns="urn:ietf:params:xml:ns:yang:yin:1"
        xmlns:al="urn:ietf:params:xml:ns:yang:ietf-alarms"
        xmlns:yang="urn:ietf:params:xml:ns:yang:ietf-yang-types">
  <yang-version value="1.1"/>
  <namespace uri="urn:ietf:params:xml:ns:yang:ietf-alarms"/>
  <prefix value="al"/>
  <import module="ietf-yang-types">
    <prefix value="yang"/>
    <reference>
      <text>RFC 6991: Common YANG Data Types.</text>
    </reference>
  </import>
  <organization>
    <text>IETF CCAMP Working Group</text>
  </organization>
  <contact>
    <text>WG Web:   &lt;https://trac.ietf.org/trac/ccamp&gt;
WG List:  &lt;mailto:ccamp@ietf.org&gt;

Editor:   Stefan Vallin
          &lt;mailto:stefan@wallan.se&gt;

Editor:   Martin Bjorklund
          &lt;mailto:mbj@tail-f.com&gt;</text>
  </contact>
  <description>
    <text>This module defines an interface for managing alarms.  Main
inputs to the module design are the 3GPP Alarm Integration
Reference Point (IRP), ITU-T X.733, and ANSI/ISA-18.2 alarm
standards.

Main features of this module include:

  * Alarm list:
            A list of all alarms.  Cleared alarms stay in
            the list until explicitly purged.

  * Operator actions on alarms:
            Acknowledging and closing alarms.

  * Administrative actions on alarms:
            Purging alarms from the list according to specific
            criteria.

  * Alarm inventory:
            A management application can read all
            alarm types implemented by the system.

  * Alarm shelving:
            Shelving (blocking) alarms according
            to specific criteria.

  * Alarm profiles:
            A management system can attach further
            information to alarm types, for example,
            overriding system-default severity
            levels.

This module uses a stateful view on alarms.  An alarm is a state
for a specific resource (note that an alarm is not a
notification).  An alarm type is a possible alarm state for a
resource.  For example, the tuple:

  ('link-alarm', 'GigabitEthernet0/25')

is an alarm of type 'link-alarm' on the resource
'GigabitEthernet0/25'.

Alarm types are identified using YANG identities and an optional
string-based qualifier.  The string-based qualifier allows for
dynamic extension of the statically defined alarm types.  Alarm
types identify a possible alarm state and not the individual
notifications.  For example, the traditional 'link-down' and
'link-up' notifications are two notifications referring to the
same alarm type 'link-alarm'.

With this design, there is no ambiguity about how alarm and
alarm clear correlation should be performed; notifications that
report the same resource and alarm type are considered updates
of the same alarm, e.g., clearing an active alarm or changing
the severity of an alarm.  The instrumentation can update the
severity and alarm text on an existing alarm.  The above alarm
example can therefore look like the following:

  (('link-alarm', 'GigabitEthernet0/25'),
   warning,
   'interface down while interface admin state is up')

There is a clear separation between updates on the alarm from
the underlying resource, like clear, and updates from an
operator, like acknowledging or closing an alarm:

  (('link-alarm', 'GigabitEthernet0/25'),
   warning,
   'interface down while interface admin state is up',
   cleared,
   closed)

Administrative actions like removing closed alarms older than a
given time is supported.

This YANG module does not define how the underlying
instrumentation detects and clears the specific alarms.  That
belongs to the Standards Development Organization (SDO) or
enterprise that owns that specific technology.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8632; see
the RFC itself for full legal notices.</text>
  </description>
  <revision date="2019-09-11">
    <description>
      <text>Initial revision.</text>
    </description>
    <reference>
      <text>RFC 8632: A YANG Data Model for Alarm Management</text>
    </reference>
  </revision>
  <feature name="operator-actions">
    <description>
      <text>This feature indicates that the system supports operator
states on alarms.</text>
    </description>
  </feature>
  <feature name="alarm-shelving">
    <description>
      <text>This feature indicates that the system supports shelving
(blocking) alarms.

Alarm shelving may have an impact on server processing
resources in order to match alarms against shelf
criteria.</text>
    </description>
  </feature>
  <feature name="alarm-history">
    <description>
      <text>This feature indicates that the server maintains a history
of state changes for each alarm.  For example, if an alarm
toggles between cleared and active 10 times, these state
changes are present in a separate list in the alarm.

Keeping the alarm history may have an impact on server
memory resources.</text>
    </description>
  </feature>
  <feature name="alarm-summary">
    <description>
      <text>This feature indicates that the server summarizes the number
of alarms per severity and operator state.</text>
    </description>
  </feature>
  <feature name="alarm-profile">
    <description>
      <text>The system enables clients to configure further information
to each alarm type.</text>
    </description>
  </feature>
  <feature name="severity-assignment">
    <description>
      <text>The system supports configurable alarm severity levels.</text>
    </description>
    <reference>
      <text>ITU-T Recommendation M.3100:
  Generic network information model
ITU-T Recommendation M.3160:
  Generic, protocol-neutral management information model</text>
    </reference>
  </feature>
  <feature name="root-cause-analysis">
    <description>
      <text>The system supports identifying candidate root-cause
resources for an alarm, for example, a disk partition
root cause for a logger failure alarm.</text>
    </description>
  </feature>
  <feature name="service-impact-analysis">
    <description>
      <text>The system supports identifying candidate-impacted
resources for an alarm, for example, an interface state change
resulting in a link alarm, which can refer to a link as being
impacted.</text>
    </description>
  </feature>
  <feature name="alarm-correlation">
    <description>
      <text>The system supports correlating/grouping alarms
that belong together.</text>
    </description>
  </feature>
  <identity name="alarm-type-id">
    <description>
      <text>Base identity for alarm types.  A unique identification of
the alarm, not including the resource.  Different resources
can share alarm types.  If the resource reports the same
alarm type, it is considered to be the same alarm.  The alarm
type is a simplification of the different X.733 and 3GPP Alarm
IRP correlation mechanisms, and it allows for
hierarchical extensions.

A string-based qualifier can be used in addition to the
identity in order to have different alarm types based on
information not known at design time, such as values in
textual SNMP Notification varbinds.

Standards and vendors can define sub-identities to clearly
identify specific alarm types.

This identity is abstract and MUST NOT be used for alarms.</text>
    </description>
  </identity>
  <typedef name="resource">
    <type name="union">
      <type name="instance-identifier">
        <require-instance value="false"/>
      </type>
      <type name="yang:object-identifier"/>
      <type name="string"/>
      <type name="yang:uuid"/>
    </type>
    <description>
      <text>This is an identification of the alarming resource, such as an
interface.  It should be as fine-grained as possible to both
guide the operator and guarantee uniqueness of the alarms.

If the alarming resource is modeled in YANG, this type will
be an instance-identifier.

If the resource is an SNMP object, the type will be an
'object-identifier'.

If the resource is anything else, for example, a distinguished
name or a Common Information Model (CIM) path, this type will
be a string.

If the alarming object is identified by a Universally Unique
Identifier (UUID), use the uuid type.  Be cautious when using
this type, since a UUID is hard to use for an operator.

If the server supports several models, the precedence should
be in the order as given in the union definition.</text>
    </description>
  </typedef>
  <typedef name="resource-match">
    <type name="union">
      <type name="yang:xpath1.0"/>
      <type name="yang:object-identifier"/>
      <type name="string"/>
    </type>
    <description>
      <text>This type is used to match resources of type 'resource'.
Since the type 'resource' is a union of different types, the
'resource-match' type is also a union of corresponding types.

If the type is given as an XPath 1.0 expression, a resource
of type 'instance-identifier' matches if the instance is part
of the node set that is the result of evaluating the XPath 1.0
expression.  For example, the XPath 1.0 expression:

 /ietf-interfaces:interfaces/ietf-interfaces:interface
     [ietf-interfaces:type='ianaift:ethernetCsmacd']

would match the resource instance-identifier:

 /if:interfaces/if:interface[if:name='eth1'],

assuming that the interface 'eth1' is of type
'ianaift:ethernetCsmacd'.

If the type is given as an object identifier, a resource of
type 'object-identifier' matches if the match object
identifier is a prefix of the resource's object identifier.
For example, the value:

 1.3.6.1.2.1.2.2

would match the resource object identifier:

 1.3.6.1.2.1.2.2.1.1.5

If the type is given as an UUID or a string, it is interpreted
as an XML Schema regular expression, which matches a resource
of type 'yang:uuid' or 'string' if the given regular
expression matches the resource string.

If the type is given as an XPath expression, it is evaluated
in the following XPath context:

  o  The set of namespace declarations is the set of prefix
     and namespace pairs for all YANG modules implemented by
     the server, where the prefix is the YANG module name and
     the namespace is as defined by the 'namespace' statement
     in the YANG module.

     If a leaf of this type is encoded in XML, all namespace
     declarations in scope on the leaf element are added to
     the set of namespace declarations.  If a prefix found in
     the XML is already present in the set of namespace
     declarations, the namespace in the XML is used.

  o  The set of variable bindings is empty.

  o  The function library is the core function library, and
     the functions are defined in Section 10 of RFC 7950.

  o  The context node is the root node in the data tree.</text>
    </description>
    <reference>
      <text>XML Schema Part 2: Datatypes Second Edition,
  World Wide Web Consortium Recommendation
  REC-xmlschema-2-20041028</text>
    </reference>
  </typedef>
  <typedef name="alarm-text">
    <type name="string"/>
    <description>
      <text>The string used to inform operators about the alarm.  This
MUST contain enough information for an operator to be able to
understand the problem and how to resolve it.  If this string
contains structure, this format should be clearly documented
for programs to be able to parse that information.</text>
    </description>
  </typedef>
  <typedef name="severity">
    <type name="enumeration">
      <enum name="indeterminate">
        <value value="2"/>
        <description>
          <text>Indicates that the severity level could not be
determined.  This level SHOULD be avoided.</text>
        </description>
      </enum>
      <enum name="warning">
        <value value="3"/>
        <description>
          <text>The 'warning' severity level indicates the detection of a
potential or impending service-affecting fault, before any
significant effects have been felt.  Action should be
taken to further diagnose (if necessary) and correct the
problem in order to prevent it from becoming a more
serious service-affecting fault.</text>
        </description>
      </enum>
      <enum name="minor">
        <value value="4"/>
        <description>
          <text>The 'minor' severity level indicates the existence of a
non-service-affecting fault condition and that corrective
action should be taken in order to prevent a more serious
(for example, service-affecting) fault.  Such a severity
can be reported, for example, when the detected alarm
condition is not currently degrading the capacity of the
resource.</text>
        </description>
      </enum>
      <enum name="major">
        <value value="5"/>
        <description>
          <text>The 'major' severity level indicates that a service-
affecting condition has developed and an urgent corrective
action is required.  Such a severity can be reported, for
example, when there is a severe degradation in the
capability of the resource and its full capability must be
restored.</text>
        </description>
      </enum>
      <enum name="critical">
        <value value="6"/>
        <description>
          <text>The 'critical' severity level indicates that a service-
affecting condition has occurred and an immediate
corrective action is required.  Such a severity can be
reported, for example, when a resource becomes totally out
of service and its capability must be restored.</text>
        </description>
      </enum>
    </type>
    <description>
      <text>The severity level of the alarm.  Note well that the value
'clear' is not included.  Whether or not an alarm is cleared
is a separate boolean flag.</text>
    </description>
    <reference>
      <text>ITU-T Recommendation X.733: Information Technology
  - Open Systems Interconnection
  - System Management: Alarm Reporting Function</text>
    </reference>
  </typedef>
  <typedef name="severity-with-clear">
    <type name="union">
      <type name="enumeration">
        <enum name="cleared">
          <value value="1"/>
          <description>
            <text>The alarm is cleared by the instrumentation.</text>
          </description>
        </enum>
      </type>
      <type name="severity"/>
    </type>
    <description>
      <text>The severity level of the alarm including clear.  This is used
only in notifications reporting state changes for an alarm.</text>
    </description>
  </typedef>
  <typedef name="writable-operator-state">
    <type name="enumeration">
      <enum name="none">
        <value value="1"/>
        <description>
          <text>The alarm is not being taken care of.</text>
        </description>
      </enum>
      <enum name="ack">
        <value value="2"/>
        <description>
          <text>The alarm is being taken care of.  Corrective action not
taken yet or has failed</text>
        </description>
      </enum>
      <enum name="closed">
        <value value="3"/>
        <description>
          <text>Corrective action taken successfully.</text>
        </description>
      </enum>
    </type>
    <description>
      <text>Operator states on an alarm.  The 'closed' state indicates
that an operator considers the alarm being resolved.  This is
separate from the alarm's 'is-cleared' leaf.</text>
    </description>
  </typedef>
  <typedef name="operator-state">
    <type name="union">
      <type name="writable-operator-state"/>
      <type name="enumeration">
        <enum name="shelved">
          <value value="4"/>
          <description>
            <text>The alarm is shelved.  Alarms in /alarms/shelved-alarms/
MUST be assigned this operator state by the server as
the last entry in the 'operator-state-change' list.  The
text for that entry SHOULD include the shelf name.</text>
          </description>
        </enum>
        <enum name="un-shelved">
          <value value="5"/>
          <description>
            <text>The alarm is moved back to 'alarm-list' from a shelf.
Alarms that are moved from /alarms/shelved-alarms/ to
/alarms/alarm-list MUST be assigned this state by the
server as the last entry in the 'operator-state-change'
list.  The text for that entry SHOULD include the shelf
name.</text>
          </description>
        </enum>
      </type>
    </type>
    <description>
      <text>Operator states on an alarm.  The 'closed' state indicates
that an operator considers the alarm being resolved.  This is
separate from the alarm's 'is-cleared' leaf.</text>
    </description>
  </typedef>
  <typedef name="alarm-type-id">
    <type name="identityref">
      <base name="alarm-type-id"/>
    </type>
    <description>
      <text>Identifies an alarm type.  The description of the alarm type
id MUST indicate whether or not the alarm type is abstract.
An abstract alarm type is used as a base for other alarm type
ids and will not be used as a value for an alarm or be present
in the alarm inventory.</text>
    </description>
  </typedef>
  <typedef name="alarm-type-qualifier">
    <type name="string"/>
    <description>
      <text>If an alarm type cannot be fully specified at design time by
'alarm-type-id', this string qualifier is used in addition to
fully define a unique alarm type.

The definition of alarm qualifiers is considered to be part of
the instrumentation and is out of scope for this module.  An
empty string is used when this is part of a key.</text>
    </description>
  </typedef>
  <grouping name="common-alarm-parameters">
    <description>
      <text>Common parameters for an alarm.

This grouping is used both in the alarm list and in the
notification representing an alarm-state change.</text>
    </description>
    <leaf name="resource">
      <type name="resource"/>
      <mandatory value="true"/>
      <description>
        <text>The alarming resource.  See also 'alt-resource'.  This could
be, for example, a reference to the alarming interface</text>
      </description>
    </leaf>
    <leaf name="alarm-type-id">
      <type name="alarm-type-id"/>
      <mandatory value="true"/>
      <description>
        <text>This leaf and the leaf 'alarm-type-qualifier' together
provide a unique identification of the alarm type.</text>
      </description>
    </leaf>
    <leaf name="alarm-type-qualifier">
      <type name="alarm-type-qualifier"/>
      <description>
        <text>This leaf is used when the 'alarm-type-id' leaf cannot
uniquely identify the alarm type.  Normally, this is not the
case, and this leaf is the empty string.</text>
      </description>
    </leaf>
    <leaf-list name="alt-resource">
      <type name="resource"/>
      <description>
        <text>Used if the alarming resource is available over other
interfaces.  This field can contain SNMP OIDs, CIM paths, or
3GPP distinguished names, for example.</text>
      </description>
    </leaf-list>
    <list name="related-alarm">
      <if-feature name="alarm-correlation"/>
      <key value="resource alarm-type-id alarm-type-qualifier"/>
      <description>
        <text>References to related alarms.  Note that the related alarm
might have been purged from the alarm list.</text>
      </description>
      <leaf name="resource">
        <type name="leafref">
          <path value="/alarms/alarm-list/alarm/resource"/>
          <require-instance value="false"/>
        </type>
        <description>
          <text>The alarming resource for the related alarm.</text>
        </description>
      </leaf>
      <leaf name="alarm-type-id">
        <type name="leafref">
          <path value="/alarms/alarm-list/alarm[resource=current()/../resource]/alarm-type-id"/>
          <require-instance value="false"/>
        </type>
        <description>
          <text>The alarm type identifier for the related alarm.</text>
        </description>
      </leaf>
      <leaf name="alarm-type-qualifier">
        <type name="leafref">
          <path value="/alarms/alarm-list/alarm[resource=current()/../resource][alarm-type-id=current()/../alarm-type-id]/alarm-type-qualifier"/>
          <require-instance value="false"/>
        </type>
        <description>
          <text>The alarm qualifier for the related alarm.</text>
        </description>
      </leaf>
    </list>
    <leaf-list name="impacted-resource">
      <if-feature name="service-impact-analysis"/>
      <type name="resource"/>
      <description>
        <text>Resources that might be affected by this alarm.  If the
system creates an alarm on a resource and also has a mapping
to other resources that might be impacted, these resources
can be listed in this leaf-list.  In this way, the system
can create one alarm instead of several.  For example, if an
interface has an alarm, the 'impacted-resource' can
reference the aggregated port channels.</text>
      </description>
    </leaf-list>
    <leaf-list name="root-cause-resource">
      <if-feature name="root-cause-analysis"/>
      <type name="resource"/>
      <description>
        <text>Resources that are candidates for causing the alarm.  If the
system has a mechanism to understand the candidate root
causes of an alarm, this leaf-list can be used to list the
root-cause candidate resources.  In this way, the system can
create one alarm instead of several.  An example might be a
logging system (alarm resource) that fails; the alarm can
reference the file system in the 'root-cause-resource'
leaf-list.  Note that the intended use is not to also send
an alarm with the 'root-cause-resource' as an alarming
resource.  The 'root-cause-resource' leaf-list is a hint and
should not also generate an alarm for the same problem.</text>
      </description>
    </leaf-list>
  </grouping>
  <grouping name="alarm-state-change-parameters">
    <description>
      <text>Parameters for an alarm-state change.

This grouping is used both in the alarm list's status-change
list and in the notification representing an alarm-state
change.</text>
    </description>
    <leaf name="time">
      <type name="yang:date-and-time"/>
      <mandatory value="true"/>
      <description>
        <text>The time the status of the alarm changed.  The value
represents the time the real alarm-state change appeared in
the resource and not when it was added to the alarm
list.  The /alarm-list/alarm/last-changed MUST be set to the
same value.</text>
      </description>
    </leaf>
    <leaf name="perceived-severity">
      <type name="severity-with-clear"/>
      <mandatory value="true"/>
      <description>
        <text>The severity of the alarm as defined by X.733.  Note that
this may not be the original severity since the alarm may
have changed severity.</text>
      </description>
      <reference>
        <text>ITU-T Recommendation X.733: Information Technology
  - Open Systems Interconnection
  - System Management: Alarm Reporting Function</text>
      </reference>
    </leaf>
    <leaf name="alarm-text">
      <type name="alarm-text"/>
      <mandatory value="true"/>
      <description>
        <text>A user-friendly text describing the alarm-state change.</text>
      </description>
      <reference>
        <text>ITU-T Recommendation X.733: Information Technology
  - Open Systems Interconnection
  - System Management: Alarm Reporting Function</text>
      </reference>
    </leaf>
  </grouping>
  <grouping name="operator-parameters">
    <description>
      <text>This grouping defines parameters that can be changed by an
operator.</text>
    </description>
    <leaf name="time">
      <type name="yang:date-and-time"/>
      <mandatory value="true"/>
      <description>
        <text>Timestamp for operator action on the alarm.</text>
      </description>
    </leaf>
    <leaf name="operator">
      <type name="string"/>
      <mandatory value="true"/>
      <description>
        <text>The name of the operator that has acted on this alarm.</text>
      </description>
    </leaf>
    <leaf name="state">
      <type name="operator-state"/>
      <mandatory value="true"/>
      <description>
        <text>The operator's view of the alarm state.</text>
      </description>
    </leaf>
    <leaf name="text">
      <type name="string"/>
      <description>
        <text>Additional optional textual information provided by the
operator.</text>
      </description>
    </leaf>
  </grouping>
  <grouping name="resource-alarm-parameters">
    <description>
      <text>Alarm parameters that originate from the resource view.</text>
    </description>
    <leaf name="is-cleared">
      <type name="boolean"/>
      <mandatory value="true"/>
      <description>
        <text>Indicates the current clearance state of the alarm.  An
alarm might toggle from active alarm to cleared alarm and
back to active again.</text>
      </description>
    </leaf>
    <leaf name="last-raised">
      <type name="yang:date-and-time"/>
      <mandatory value="true"/>
      <description>
        <text>An alarm may change severity level and toggle between
active and cleared during its lifetime.  This leaf indicates
the last time it was raised ('is-cleared' = 'false').</text>
      </description>
    </leaf>
    <leaf name="last-changed">
      <type name="yang:date-and-time"/>
      <mandatory value="true"/>
      <description>
        <text>A timestamp when the 'status-change' or
'operator-state-change' list was last changed.</text>
      </description>
    </leaf>
    <leaf name="perceived-severity">
      <type name="severity"/>
      <mandatory value="true"/>
      <description>
        <text>The last severity of the alarm.

If an alarm was raised with severity 'warning' but later
changed to 'major', this leaf will show 'major'.</text>
      </description>
    </leaf>
    <leaf name="alarm-text">
      <type name="alarm-text"/>
      <mandatory value="true"/>
      <description>
        <text>The last reported alarm text.  This text should contain
information for an operator to be able to understand the
problem and how to resolve it.</text>
      </description>
    </leaf>
    <list name="status-change">
      <if-feature name="alarm-history"/>
      <key value="time"/>
      <min-elements value="1"/>
      <description>
        <text>A list of status-change events for this alarm.

The entry with latest timestamp in this list MUST
correspond to the leafs 'is-cleared', 'perceived-severity',
and 'alarm-text' for the alarm.

This list is ordered according to the timestamps of alarm
state changes.  The first item corresponds to the latest
state change.

The following state changes create an entry in this
list:
- changed severity (warning, minor, major, critical)
- clearance status; this also updates the 'is-cleared'
  leaf
- alarm-text update</text>
      </description>
      <uses name="alarm-state-change-parameters"/>
    </list>
  </grouping>
  <grouping name="filter-input">
    <description>
      <text>Grouping to specify a filter construct on alarm information.</text>
    </description>
    <leaf name="alarm-clearance-status">
      <type name="enumeration">
        <enum name="any">
          <description>
            <text>Ignore alarm-clearance status.</text>
          </description>
        </enum>
        <enum name="cleared">
          <description>
            <text>Filter cleared alarms.</text>
          </description>
        </enum>
        <enum name="not-cleared">
          <description>
            <text>Filter not-cleared alarms.</text>
          </description>
        </enum>
      </type>
      <mandatory value="true"/>
      <description>
        <text>The clearance status of the alarm.</text>
      </description>
    </leaf>
    <container name="older-than">
      <presence value="Age specification"/>
      <description>
        <text>Matches the 'last-status-change' leaf in the alarm.</text>
      </description>
      <choice name="age-spec">
        <description>
          <text>Filter using date and time age.</text>
        </description>
        <case name="seconds">
          <leaf name="seconds">
            <type name="uint16"/>
            <description>
              <text>Age expressed in seconds.</text>
            </description>
          </leaf>
        </case>
        <case name="minutes">
          <leaf name="minutes">
            <type name="uint16"/>
            <description>
              <text>Age expressed in minutes.</text>
            </description>
          </leaf>
        </case>
        <case name="hours">
          <leaf name="hours">
            <type name="uint16"/>
            <description>
              <text>Age expressed in hours.</text>
            </description>
          </leaf>
        </case>
        <case name="days">
          <leaf name="days">
            <type name="uint16"/>
            <description>
              <text>Age expressed in days.</text>
            </description>
          </leaf>
        </case>
        <case name="weeks">
          <leaf name="weeks">
            <type name="uint16"/>
            <description>
              <text>Age expressed in weeks.</text>
            </description>
          </leaf>
        </case>
      </choice>
    </container>
    <container name="severity">
      <presence value="Severity filter"/>
      <choice name="sev-spec">
        <description>
          <text>Filter based on severity level.</text>
        </description>
        <leaf name="below">
          <type name="severity"/>
          <description>
            <text>Severity less than this leaf.</text>
          </description>
        </leaf>
        <leaf name="is">
          <type name="severity"/>
          <description>
            <text>Severity level equal to this leaf.</text>
          </description>
        </leaf>
        <leaf name="above">
          <type name="severity"/>
          <description>
            <text>Severity level higher than this leaf.</text>
          </description>
        </leaf>
      </choice>
      <description>
        <text>Filter based on severity.</text>
      </description>
    </container>
    <container name="operator-state-filter">
      <if-feature name="operator-actions"/>
      <presence value="Operator state filter"/>
      <leaf name="state">
        <type name="operator-state"/>
        <description>
          <text>Filter on operator state.</text>
        </description>
      </leaf>
      <leaf name="user">
        <type name="string"/>
        <description>
          <text>Filter based on which operator.</text>
        </description>
      </leaf>
      <description>
        <text>Filter based on operator state.</text>
      </description>
    </container>
  </grouping>
  <container name="alarms">
    <description>
      <text>The top container for this module.</text>
    </description>
    <container name="control">
      <description>
        <text>Configuration to control the alarm behavior.</text>
      </description>
      <leaf name="max-alarm-status-changes">
        <type name="union">
          <type name="uint16"/>
          <type name="enumeration">
            <enum name="infinite">
              <description>
                <text>The status-change entries are accumulated
infinitely.</text>
              </description>
            </enum>
          </type>
        </type>
        <default value="32"/>
        <description>
          <text>The 'status-change' entries are kept in a circular list
per alarm.  When this number is exceeded, the oldest
status change entry is automatically removed.  If the
value is 'infinite', the status-change entries are
accumulated infinitely.</text>
        </description>
      </leaf>
      <leaf name="notify-status-changes">
        <type name="enumeration">
          <enum name="all-state-changes">
            <description>
              <text>Send notifications for all status changes.</text>
            </description>
          </enum>
          <enum name="raise-and-clear">
            <description>
              <text>Send notifications only for raise, clear, and
re-raise.  Notifications for severity-level changes or
alarm-text changes are not sent.</text>
            </description>
          </enum>
          <enum name="severity-level">
            <description>
              <text>Only send notifications for alarm-state changes
crossing the level specified in
'notify-severity-level'.  Always send clear
notifications.</text>
            </description>
          </enum>
        </type>
        <must condition='. != "severity-level" or ../notify-severity-level'>
          <description>
            <text>When notify-status-changes is 'severity-level', a value
must be given for 'notify-severity-level'.</text>
          </description>
        </must>
        <default value="all-state-changes"/>
        <description>
          <text>This leaf controls the notifications sent for alarm status
updates.  There are three options:

1.  Notifications are sent for all updates, severity-level
    changes, and alarm-text changes.

2.  Notifications are only sent for alarm raise and clear.

3.  Notifications are sent for status changes equal to or
    above the specified severity level.  Clear
    notifications shall always be sent.  Notifications
    shall also be sent for state changes that make an
    alarm less severe than the specified level.

For example, in option 3, assume that the severity level
is set to major and that the alarm has the following state
changes:

[(Time, severity, clear)]:
[(T1, major, -), (T2, minor, -), (T3, warning, -),
 (T4, minor, -), (T5, major, -), (T6, critical, -),
 (T7, major.  -), (T8, major, clear)]

In that case, notifications will be sent at times
T1, T2, T5, T6, T7, and T8.</text>
        </description>
      </leaf>
      <leaf name="notify-severity-level">
        <when condition='../notify-status-changes = "severity-level"'/>
        <type name="severity"/>
        <description>
          <text>Only send notifications for alarm-state changes crossing
the specified level.  Always send clear notifications.</text>
        </description>
      </leaf>
      <container name="alarm-shelving">
        <if-feature name="alarm-shelving"/>
        <description>
          <text>The 'alarm-shelving/shelf' list is used to shelve
(block/filter) alarms.  The conditions in the shelf
criteria are logically ANDed.  The first matching shelf is
used, and an alarm is shelved only for this first match.
Matching alarms MUST appear in the
/alarms/shelved-alarms/shelved-alarm list, and
non-matching /alarms MUST appear in the
/alarms/alarm-list/alarm list.  The server does not send
any notifications for shelved alarms.

The server MUST maintain states (e.g., severity
changes) for the shelved alarms.

Alarms that match the criteria shall have an
operator state 'shelved'.  When the shelf
configuration removes an alarm from the shelf, the server
shall add the operator state 'un-shelved'.</text>
        </description>
        <list name="shelf">
          <key value="name"/>
          <ordered-by value="user"/>
          <leaf name="name">
            <type name="string"/>
            <description>
              <text>An arbitrary name for the alarm shelf.</text>
            </description>
          </leaf>
          <description>
            <text>Each entry defines the criteria for shelving alarms.
Criteria are ANDed.  If no criteria are specified,
all alarms will be shelved.</text>
          </description>
          <leaf-list name="resource">
            <type name="resource-match"/>
            <description>
              <text>Shelve alarms for matching resources.</text>
            </description>
          </leaf-list>
          <list name="alarm-type">
            <key value="alarm-type-id alarm-type-qualifier-match"/>
            <description>
              <text>Any alarm matching the combined criteria of
'alarm-type-id' and 'alarm-type-qualifier-match'
MUST be matched.</text>
            </description>
            <leaf name="alarm-type-id">
              <type name="alarm-type-id"/>
              <description>
                <text>Shelve all alarms that have an 'alarm-type-id' that
is equal to or derived from the given
'alarm-type-id'.</text>
              </description>
            </leaf>
            <leaf name="alarm-type-qualifier-match">
              <type name="string"/>
              <description>
                <text>An XML Schema regular expression that is used to
match an alarm type qualifier.  Shelve all alarms
that match this regular expression for the alarm
type qualifier.</text>
              </description>
              <reference>
                <text>XML Schema Part 2: Datatypes Second Edition,
  World Wide Web Consortium Recommendation
  REC-xmlschema-2-20041028</text>
              </reference>
            </leaf>
          </list>
          <leaf name="description">
            <type name="string"/>
            <description>
              <text>An optional textual description of the shelf.  This
description should include the reason for shelving
these alarms.</text>
            </description>
          </leaf>
        </list>
      </container>
    </container>
    <container name="alarm-inventory">
      <config value="false"/>
      <description>
        <text>The 'alarm-inventory/alarm-type' list contains all possible
alarm types for the system.

If the system knows for which resources a specific alarm
type can appear, it is also identified in the inventory.
The list also tells if each alarm type has a corresponding
clear state.  The inventory shall only contain concrete
alarm types.

The alarm inventory MUST be updated by the system when new
alarms can appear.  This can be the case when installing new
software modules or inserting new card types.  A
notification 'alarm-inventory-changed' is sent when the
inventory is changed.</text>
      </description>
      <list name="alarm-type">
        <key value="alarm-type-id alarm-type-qualifier"/>
        <description>
          <text>An entry in this list defines a possible alarm.</text>
        </description>
        <leaf name="alarm-type-id">
          <type name="alarm-type-id"/>
          <description>
            <text>The statically defined alarm type identifier for this
possible alarm.</text>
          </description>
        </leaf>
        <leaf name="alarm-type-qualifier">
          <type name="alarm-type-qualifier"/>
          <description>
            <text>The optionally dynamically defined alarm type identifier
for this possible alarm.</text>
          </description>
        </leaf>
        <leaf-list name="resource">
          <type name="resource-match"/>
          <description>
            <text>Optionally, specifies for which resources the alarm type
is valid.</text>
          </description>
        </leaf-list>
        <leaf name="will-clear">
          <type name="boolean"/>
          <mandatory value="true"/>
          <description>
            <text>This leaf tells the operator if the alarm will be
cleared when the correct corrective action has been
taken.  Implementations SHOULD strive for detecting the
cleared state for all alarm types.

If this leaf is 'true', the operator can monitor the
alarm until it becomes cleared after the corrective
action has been taken.

If this leaf is 'false', the operator needs to validate
that the alarm is no longer active using other
mechanisms.  Alarms can lack a corresponding clear due
to missing instrumentation or no logical
corresponding clear state.</text>
          </description>
        </leaf>
        <leaf-list name="severity-level">
          <type name="severity"/>
          <description>
            <text>This leaf-list indicates the possible severity levels of
this alarm type.  Note well that 'clear' is not part of
the severity type.  In general, the severity level
should be defined by the instrumentation based on the
dynamic state, rather than being defined statically by
the alarm type, in order to provide a relevant severity
level based on dynamic state and context.  However, most
alarm types have a defined set of possible severity
levels, and this should be provided here.</text>
          </description>
        </leaf-list>
        <leaf name="description">
          <type name="string"/>
          <mandatory value="true"/>
          <description>
            <text>A description of the possible alarm.  It SHOULD include
information on possible underlying root causes and
corrective actions.</text>
          </description>
        </leaf>
      </list>
    </container>
    <container name="summary">
      <if-feature name="alarm-summary"/>
      <config value="false"/>
      <description>
        <text>This container gives a summary of the number of alarms.</text>
      </description>
      <list name="alarm-summary">
        <key value="severity"/>
        <description>
          <text>A global summary of all alarms in the system.  The summary
does not include shelved alarms.</text>
        </description>
        <leaf name="severity">
          <type name="severity"/>
          <description>
            <text>Alarm summary for this severity level.</text>
          </description>
        </leaf>
        <leaf name="total">
          <type name="yang:gauge32"/>
          <description>
            <text>Total number of alarms of this severity level.</text>
          </description>
        </leaf>
        <leaf name="not-cleared">
          <type name="yang:gauge32"/>
          <description>
            <text>Total number of alarms of this severity level
that are not cleared.</text>
          </description>
        </leaf>
        <leaf name="cleared">
          <type name="yang:gauge32"/>
          <description>
            <text>For this severity level, the number of alarms that are
cleared.</text>
          </description>
        </leaf>
        <leaf name="cleared-not-closed">
          <if-feature name="operator-actions"/>
          <type name="yang:gauge32"/>
          <description>
            <text>For this severity level, the number of alarms that are
cleared but not closed.</text>
          </description>
        </leaf>
        <leaf name="cleared-closed">
          <if-feature name="operator-actions"/>
          <type name="yang:gauge32"/>
          <description>
            <text>For this severity level, the number of alarms that are
cleared and closed.</text>
          </description>
        </leaf>
        <leaf name="not-cleared-closed">
          <if-feature name="operator-actions"/>
          <type name="yang:gauge32"/>
          <description>
            <text>For this severity level, the number of alarms that are
not cleared but closed.</text>
          </description>
        </leaf>
        <leaf name="not-cleared-not-closed">
          <if-feature name="operator-actions"/>
          <type name="yang:gauge32"/>
          <description>
            <text>For this severity level, the number of alarms that are
not cleared and not closed.</text>
          </description>
        </leaf>
      </list>
      <leaf name="shelves-active">
        <if-feature name="alarm-shelving"/>
        <type name="empty"/>
        <description>
          <text>This is a hint to the operator that there are active
alarm shelves.  This leaf MUST exist if the
/alarms/shelved-alarms/number-of-shelved-alarms is &gt; 0.</text>
        </description>
      </leaf>
    </container>
    <container name="alarm-list">
      <config value="false"/>
      <description>
        <text>The alarms in the system.</text>
      </description>
      <leaf name="number-of-alarms">
        <type name="yang:gauge32"/>
        <description>
          <text>This object shows the total number of
alarms in the system, i.e., the total number
of entries in the alarm list.</text>
        </description>
      </leaf>
      <leaf name="last-changed">
        <type name="yang:date-and-time"/>
        <description>
          <text>A timestamp when the alarm list was last
changed.  The value can be used by a manager to
initiate an alarm resynchronization procedure.</text>
        </description>
      </leaf>
      <list name="alarm">
        <key value="resource alarm-type-id alarm-type-qualifier"/>
        <description>
          <text>The list of alarms.  Each entry in the list holds one
alarm for a given alarm type and resource.  An alarm can
be updated from the underlying resource or by the user.
The following leafs are maintained by the resource:
'is-cleared', 'last-change', 'perceived-severity', and
'alarm-text'.  An operator can change 'operator-state' and
'operator-text'.

Entries appear in the alarm list the first time an alarm
becomes active for a given alarm type and resource.
Entries do not get deleted when the alarm is cleared.
Clear status is represented as a boolean flag.

Alarm entries are removed, i.e., purged, from the list by
an explicit purge action.  For example, purge all alarms
that are cleared and in closed operator state that are
older than 24 hours.  Purged alarms are removed from the
alarm list.  If the alarm resource state changes after a
purge, the alarm will reappear in the alarm list.

Systems may also remove alarms based on locally configured
policies; this is out of scope for this module.</text>
        </description>
        <uses name="common-alarm-parameters"/>
        <leaf name="time-created">
          <type name="yang:date-and-time"/>
          <mandatory value="true"/>
          <description>
            <text>The timestamp when this alarm entry was created.  This
represents the first time the alarm appeared; it can
also represent that the alarm reappeared after a purge.
Further state changes of the same alarm do not change
this leaf; these changes will update the 'last-changed'
leaf.</text>
          </description>
        </leaf>
        <uses name="resource-alarm-parameters"/>
        <list name="operator-state-change">
          <if-feature name="operator-actions"/>
          <key value="time"/>
          <description>
            <text>This list is used by operators to indicate the state of
human intervention on an alarm.  For example, if an
operator has seen an alarm, the operator can add a new
item to this list indicating that the alarm is
acknowledged.</text>
          </description>
          <uses name="operator-parameters"/>
        </list>
        <action name="set-operator-state">
          <if-feature name="operator-actions"/>
          <description>
            <text>This is a means for the operator to indicate the level
of human intervention on an alarm.</text>
          </description>
          <input>
            <leaf name="state">
              <type name="writable-operator-state"/>
              <mandatory value="true"/>
              <description>
                <text>Set this operator state.</text>
              </description>
            </leaf>
            <leaf name="text">
              <type name="string"/>
              <description>
                <text>Additional optional textual information.</text>
              </description>
            </leaf>
          </input>
        </action>
        <notification name="operator-action">
          <if-feature name="operator-actions"/>
          <description>
            <text>This notification is used to report that an operator
acted upon an alarm.</text>
          </description>
          <uses name="operator-parameters"/>
        </notification>
      </list>
      <action name="purge-alarms">
        <description>
          <text>This operation requests that the server delete entries
from the alarm list according to the supplied criteria.

Typically, this operation is used to delete alarms that
are in closed operator state and older than a specified
time.

The number of purged alarms is returned as an output
parameter.</text>
        </description>
        <input>
          <uses name="filter-input"/>
        </input>
        <output>
          <leaf name="purged-alarms">
            <type name="uint32"/>
            <description>
              <text>Number of purged alarms.</text>
            </description>
          </leaf>
        </output>
      </action>
      <action name="compress-alarms">
        <if-feature name="alarm-history"/>
        <description>
          <text>This operation requests that the server compress
entries in the alarm list by removing all but the
latest 'status-change' entry for all matching alarms.
Conditions in the input are logically ANDed.  If no
input condition is given, all alarms are compressed.</text>
        </description>
        <input>
          <leaf name="resource">
            <type name="resource-match"/>
            <description>
              <text>Compress the alarms matching this resource.</text>
            </description>
          </leaf>
          <leaf name="alarm-type-id">
            <type name="leafref">
              <path value="/alarms/alarm-list/alarm/alarm-type-id"/>
              <require-instance value="false"/>
            </type>
            <description>
              <text>Compress alarms with this 'alarm-type-id'.</text>
            </description>
          </leaf>
          <leaf name="alarm-type-qualifier">
            <type name="leafref">
              <path value="/alarms/alarm-list/alarm/alarm-type-qualifier"/>
              <require-instance value="false"/>
            </type>
            <description>
              <text>Compress the alarms with this
'alarm-type-qualifier'.</text>
            </description>
          </leaf>
        </input>
        <output>
          <leaf name="compressed-alarms">
            <type name="uint32"/>
            <description>
              <text>Number of compressed alarm entries.</text>
            </description>
          </leaf>
        </output>
      </action>
    </container>
    <container name="shelved-alarms">
      <if-feature name="alarm-shelving"/>
      <config value="false"/>
      <description>
        <text>The shelved alarms.  Alarms appear here if they match the
criteria in /alarms/control/alarm-shelving.  This list does
not generate any notifications.  The list represents alarms
that are considered not relevant by the operator.  Alarms in
this list have an 'operator-state' of 'shelved'.  This
cannot be changed.</text>
      </description>
      <leaf name="number-of-shelved-alarms">
        <type name="yang:gauge32"/>
        <description>
          <text>This object shows the total number of current
alarms, i.e., the total number of entries
in the alarm list.</text>
        </description>
      </leaf>
      <leaf name="shelved-alarms-last-changed">
        <type name="yang:date-and-time"/>
        <description>
          <text>A timestamp when the shelved-alarm list was last changed.
The value can be used by a manager to initiate an alarm
resynchronization procedure.</text>
        </description>
      </leaf>
      <list name="shelved-alarm">
        <key value="resource alarm-type-id alarm-type-qualifier"/>
        <description>
          <text>The list of shelved alarms.  Shelved alarms can only be
updated from the underlying resource; no operator actions
are supported.</text>
        </description>
        <uses name="common-alarm-parameters"/>
        <leaf name="shelf-name">
          <type name="leafref">
            <path value="/alarms/control/alarm-shelving/shelf/name"/>
            <require-instance value="false"/>
          </type>
          <description>
            <text>The name of the shelf.</text>
          </description>
        </leaf>
        <uses name="resource-alarm-parameters"/>
        <list name="operator-state-change">
          <if-feature name="operator-actions"/>
          <key value="time"/>
          <description>
            <text>This list is used by operators to indicate the state of
human intervention on an alarm.  For shelved alarms, the
system has set the list item in the list to 'shelved'.</text>
          </description>
          <uses name="operator-parameters"/>
        </list>
      </list>
      <action name="purge-shelved-alarms">
        <description>
          <text>This operation requests that the server delete entries from
the shelved-alarm list according to the supplied criteria.
In the shelved-alarm list, it makes sense to delete alarms
that are not relevant anymore.

The number of purged alarms is returned as an output
parameter.</text>
        </description>
        <input>
          <uses name="filter-input"/>
        </input>
        <output>
          <leaf name="purged-alarms">
            <type name="uint32"/>
            <description>
              <text>Number of purged alarms.</text>
            </description>
          </leaf>
        </output>
      </action>
      <action name="compress-shelved-alarms">
        <if-feature name="alarm-history"/>
        <description>
          <text>This operation requests that the server compress entries
in the shelved-alarm list by removing all but the latest
'status-change' entry for all matching shelved alarms.
Conditions in the input are logically ANDed.  If no input
condition is given, all alarms are compressed.</text>
        </description>
        <input>
          <leaf name="resource">
            <type name="leafref">
              <path value="/alarms/shelved-alarms/shelved-alarm/resource"/>
              <require-instance value="false"/>
            </type>
            <description>
              <text>Compress the alarms with this resource.</text>
            </description>
          </leaf>
          <leaf name="alarm-type-id">
            <type name="leafref">
              <path value="/alarms/shelved-alarms/shelved-alarm/alarm-type-id"/>
              <require-instance value="false"/>
            </type>
            <description>
              <text>Compress alarms with this 'alarm-type-id'.</text>
            </description>
          </leaf>
          <leaf name="alarm-type-qualifier">
            <type name="leafref">
              <path value="/alarms/shelved-alarms/shelved-alarm/alarm-type-qualifier"/>
              <require-instance value="false"/>
            </type>
            <description>
              <text>Compress the alarms with this
'alarm-type-qualifier'.</text>
            </description>
          </leaf>
        </input>
        <output>
          <leaf name="compressed-alarms">
            <type name="uint32"/>
            <description>
              <text>Number of compressed alarm entries.</text>
            </description>
          </leaf>
        </output>
      </action>
    </container>
    <list name="alarm-profile">
      <if-feature name="alarm-profile"/>
      <key value="alarm-type-id alarm-type-qualifier-match resource"/>
      <ordered-by value="user"/>
      <description>
        <text>This list is used to assign further information or
configuration for each alarm type.  This module supports a
mechanism where the client can override the system-default
alarm severity levels.  The 'alarm-profile' is also a useful
augmentation point for specific additions to alarm types.</text>
      </description>
      <leaf name="alarm-type-id">
        <type name="alarm-type-id"/>
        <description>
          <text>The alarm type identifier to match.</text>
        </description>
      </leaf>
      <leaf name="alarm-type-qualifier-match">
        <type name="string"/>
        <description>
          <text>An XML Schema regular expression that is used to match the
alarm type qualifier.</text>
        </description>
        <reference>
          <text>XML Schema Part 2: Datatypes Second Edition,
  World Wide Web Consortium Recommendation
  REC-xmlschema-2-20041028</text>
        </reference>
      </leaf>
      <leaf name="resource">
        <type name="resource-match"/>
        <description>
          <text>Specifies which resources to match.</text>
        </description>
      </leaf>
      <leaf name="description">
        <type name="string"/>
        <mandatory value="true"/>
        <description>
          <text>A description of the alarm profile.</text>
        </description>
      </leaf>
      <container name="alarm-severity-assignment-profile">
        <if-feature name="severity-assignment"/>
        <description>
          <text>The client can override the system-default severity
level.</text>
        </description>
        <reference>
          <text>ITU-T Recommendation M.3100:
  Generic network information model
ITU-T Recommendation M.3160:
  Generic, protocol-neutral management information model</text>
        </reference>
        <leaf-list name="severity-level">
          <type name="severity"/>
          <ordered-by value="user"/>
          <description>
            <text>Specifies the configured severity level(s) for the
matching alarm.  If the alarm has several severity
levels, the leaf-list shall be given in rising severity
order.  The original M3100/M3160 ASAP function only
allows for a one-to-one mapping between alarm type and
severity, but since YANG module supports stateful
alarms, the mapping must allow for several severity
levels.

Assume a high-utilization alarm type with two thresholds
with the system-default severity levels of threshold1 =
warning and threshold2 = minor.  Setting this leaf-list
to (minor, major) will assign the severity levels as
threshold1 = minor and threshold2 = major</text>
          </description>
        </leaf-list>
      </container>
    </list>
  </container>
  <notification name="alarm-notification">
    <description>
      <text>This notification is used to report a state change for an
alarm.  The same notification is used for reporting a newly
raised alarm, a cleared alarm, or changing the text and/or
severity of an existing alarm.</text>
    </description>
    <uses name="common-alarm-parameters"/>
    <uses name="alarm-state-change-parameters"/>
  </notification>
  <notification name="alarm-inventory-changed">
    <description>
      <text>This notification is used to report that the list of possible
alarms has changed.  This can happen when, for example, a new
software module is installed or a new physical card is
inserted.</text>
    </description>
  </notification>
</module>
