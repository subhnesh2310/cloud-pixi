<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gx_rpcs API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gx_rpcs</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#

def activate_file(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for upload
            label - str - Label to be activated
            db_instance - str - Database instance name to activate.
            sanity_check_override - bool - Allows user to skip the 
                database/swimage sanity check.
            db_action - str - Specify the expected database operation during 
                activating software image.
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    label = kwargs.get(&#39;label&#39;, None)
    db_instance = kwargs.get(&#39;db_instance&#39;, None)
    sanity_check_override = kwargs.get(&#39;sanity_check_override&#39;, None)
    db_action = kwargs.get(&#39;db_action&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;label&#34;: label,
        &#34;db-instance&#34;: db_instance,
        &#34;sanity-check-override&#34;: sanity_check_override,
        &#34;db-action&#34;: db_action,
        &#34;db-passphrase&#34;: db_passphrase
    }

    response = gxutils.send_rpc(manager, &#39;activate-file&#39;, request)
    return response


def activate_fw(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            fw_image_name - unknown - FW file name
            resource - str - List of equipment to be activated.

    ----------------------------
    &#34;&#34;&#34;

    fw_image_name = kwargs.get(&#39;fw_image_name&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;fw-image-name&#34;: fw_image_name,
        &#34;resource&#34;: resource
    }

    response = gxutils.send_rpc(manager, &#39;activate-fw&#39;, request)
    return response


def appctl(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            command - str - Application control commands.
            app_name - unknown - Third party app name.
            target - str - Entire system or chassis/card AID.
            parameters - str - Optional parameters to be passed in the command.

    ----------------------------
    &#34;&#34;&#34;

    command = kwargs.get(&#39;command&#39;, None)
    app_name = kwargs.get(&#39;app_name&#39;, None)
    target = kwargs.get(&#39;target&#39;, None)
    parameters = kwargs.get(&#39;parameters&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;command&#34;: command,
        &#34;app-name&#34;: app_name,
        &#34;target&#34;: target,
        &#34;parameters&#34;: parameters
    }

    response = gxutils.send_rpc(manager, &#39;appctl&#39;, request)
    return response


def apply_template(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            template_type - str - The type of template to apply. Other 
                parameters may be required depending on the template type.
            applicable_tom - str - List of TOMs to which to apply 
                serdes-templates against. If not provided (e.g. list is empty), all 
                system TOMs will be considered for application.

    ----------------------------
    &#34;&#34;&#34;

    template_type = kwargs.get(&#39;template_type&#39;, None)
    applicable_tom = kwargs.get(&#39;applicable_tom&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;template-type&#34;: template_type,
        &#34;applicable-tom&#34;: applicable_tom
    }

    response = gxutils.send_rpc(manager, &#39;apply-template&#39;, request)
    return response


def call_home(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            dial_out_server_name - unknown - The dial-out-server to connect to.

    ----------------------------
    &#34;&#34;&#34;

    dial_out_server_name = kwargs.get(&#39;dial_out_server_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;dial-out-server-name&#34;: dial_out_server_name
    }

    response = gxutils.send_rpc(manager, &#39;call-home&#39;, request)
    return response


def cancel_commit(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            persist_id - str - This parameter is given in order to cancel a 
                persistent confirmed commit. The value must be equal to the value 
                given in the &#39;persist&#39; parameter to the &lt;commit&gt; operation. If it 
                does not match, the operation fails with an &#39;invalid-value&#39; error.

    ----------------------------
    &#34;&#34;&#34;

    persist_id = kwargs.get(&#39;persist_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;persist-id&#34;: persist_id
    }

    response = gxutils.send_rpc(manager, &#39;cancel-commit&#39;, request)
    return response


def cancel_upgrade(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;cancel-upgrade&#39;, request)
    return response


def cert_gen(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            certificate_name - str - Specifies the name of the certificate to be 
                generated.
            days - int - Number of days a certificate is valid for.
            org_name - str - Organization Name.
            common_name - str - IP or hostname to identify the server.
            subject - str - The full certificate subject name
            auto_install - bool - Auto-assign certificate to any 
                secure-application without active certificate.

    ----------------------------
    &#34;&#34;&#34;

    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    days = kwargs.get(&#39;days&#39;, None)
    org_name = kwargs.get(&#39;org_name&#39;, None)
    common_name = kwargs.get(&#39;common_name&#39;, None)
    subject = kwargs.get(&#39;subject&#39;, None)
    auto_install = kwargs.get(&#39;auto_install&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;certificate-name&#34;: certificate_name,
        &#34;days&#34;: days,
        &#34;org-name&#34;: org_name,
        &#34;common-name&#34;: common_name,
        &#34;subject&#34;: subject,
        &#34;auto-install&#34;: auto_install
    }

    response = gxutils.send_rpc(manager, &#39;cert-gen&#39;, request)
    return response


def change_ztp_mode(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ztp_mode - str - Selects new ztp mode.

    ----------------------------
    &#34;&#34;&#34;

    ztp_mode = kwargs.get(&#39;ztp_mode&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ztp-mode&#34;: ztp_mode
    }

    response = gxutils.send_rpc(manager, &#39;change-ztp-mode&#39;, request)
    return response


def clear_alarm(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            alarm_type - unknown - Type of alarm to be cleared. Note: only some 
                alarms are eligible to be cleared using this operation; see 
                alarm-inventory/can-be-cleared-by-user for details.
            resource - unknown - Resource of alarm to be cleared. May be one or 
                more resources assocaited with the provided alarm-type.

    ----------------------------
    &#34;&#34;&#34;

    alarm_type = kwargs.get(&#39;alarm_type&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;alarm-type&#34;: alarm_type,
        &#34;resource&#34;: resource
    }

    response = gxutils.send_rpc(manager, &#39;clear-alarm&#39;, request)
    return response


def clear_app(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            app_name - unknown - Third party app name.

    ----------------------------
    &#34;&#34;&#34;

    app_name = kwargs.get(&#39;app_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;app-name&#34;: app_name
    }

    response = gxutils.send_rpc(manager, &#39;clear-app&#39;, request)
    return response


def clear_certificate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Defines the type of &#39;clear certificate&#39; that the system 
                must do.
            id - str - Foreign Key pointing to the id of the certificate to 
                delete.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    id = kwargs.get(&#39;id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;id&#34;: id
    }

    response = gxutils.send_rpc(manager, &#39;clear-certificate&#39;, request)
    return response


def clear_crl(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            clear_target - str - Defines the target CRL(s) of the clear operation.
            crl_name - unknown - Name of the CRL to delete.

    ----------------------------
    &#34;&#34;&#34;

    clear_target = kwargs.get(&#39;clear_target&#39;, None)
    crl_name = kwargs.get(&#39;crl_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;clear-target&#34;: clear_target,
        &#34;crl-name&#34;: crl_name
    }

    response = gxutils.send_rpc(manager, &#39;clear-crl&#39;, request)
    return response


def clear_database(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            clear_type - str - Defines the type of &#39;clear database&#39; that the 
                system must do.

    ----------------------------
    &#34;&#34;&#34;

    clear_type = kwargs.get(&#39;clear_type&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;clear-type&#34;: clear_type
    }

    response = gxutils.send_rpc(manager, &#39;clear-database&#39;, request)
    return response


def clear_diagnostics(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity_id - str - Target entity for the command. Must exist.
            test_signal_direction - str - The test signal direction. If not 
                specified, the counter for the enabled direction would be cleared.

    ----------------------------
    &#34;&#34;&#34;

    entity_id = kwargs.get(&#39;entity_id&#39;, None)
    test_signal_direction = kwargs.get(&#39;test_signal_direction&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity-id&#34;: entity_id,
        &#34;test-signal-direction&#34;: test_signal_direction
    }

    response = gxutils.send_rpc(manager, &#39;clear-diagnostics&#39;, request)
    return response


def clear_file(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for clearing the file
            target_file - str - Filepath of the file to be deleted

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    target_file = kwargs.get(&#39;target_file&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;target-file&#34;: target_file
    }

    response = gxutils.send_rpc(manager, &#39;clear-file&#39;, request)
    return response


def clear_log(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            log_file_name - unknown - The log file to clear; file will still 
                exist, but with empty content.

    ----------------------------
    &#34;&#34;&#34;

    log_file_name = kwargs.get(&#39;log_file_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;log-file-name&#34;: log_file_name
    }

    response = gxutils.send_rpc(manager, &#39;clear-log&#39;, request)
    return response


def clear_ospf_instance(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            instance - unknown - OSPF protocol instance which need to be 
                re-started.

    ----------------------------
    &#34;&#34;&#34;

    instance = kwargs.get(&#39;instance&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;instance&#34;: instance
    }

    response = gxutils.send_rpc(manager, &#39;clear-ospf-instance&#39;, request)
    return response


def clear_pm(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            data_type - str - Type of PM data to clear.
            period - str - Time period for PM data.
            direction - str - PM parameter direction.
            location - str - PM parameter location.
            resource - str - Existing system resource.
            resource_type - str - Type of resource.
            AID - str - Resource Access Identifier (AID). Identifies an instance 
                within a specific resource type.

    ----------------------------
    &#34;&#34;&#34;

    data_type = kwargs.get(&#39;data_type&#39;, None)
    period = kwargs.get(&#39;period&#39;, None)
    direction = kwargs.get(&#39;direction&#39;, None)
    location = kwargs.get(&#39;location&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)
    resource_type = kwargs.get(&#39;resource_type&#39;, None)
    AID = kwargs.get(&#39;AID&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;data-type&#34;: data_type,
        &#34;period&#34;: period,
        &#34;direction&#34;: direction,
        &#34;location&#34;: location,
        &#34;resource&#34;: resource,
        &#34;resource-type&#34;: resource_type,
        &#34;AID&#34;: AID
    }

    response = gxutils.send_rpc(manager, &#39;clear-pm&#39;, request)
    return response


def clear_recover_mode(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;clear-recover-mode&#39;, request)
    return response


def clear_system(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Clear system type.
            target - str - Entire system (main controller chassis) or specific 
                chassis/card AID.
            restart_behavior - str - Action to do after the clean operation.
            action - str - Action to clean the partition.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    target = kwargs.get(&#39;target&#39;, None)
    restart_behavior = kwargs.get(&#39;restart_behavior&#39;, None)
    action = kwargs.get(&#39;action&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;target&#34;: target,
        &#34;restart-behavior&#34;: restart_behavior,
        &#34;action&#34;: action
    }

    response = gxutils.send_rpc(manager, &#39;clear-system&#39;, request)
    return response


def clear_topology(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            target - str - Target instance to be cleared. May be a 
                lldp-neighbor, a carrier-neighbor or a lldp-port-statistics instance.

    ----------------------------
    &#34;&#34;&#34;

    target = kwargs.get(&#39;target&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;target&#34;: target
    }

    response = gxutils.send_rpc(manager, &#39;clear-topology&#39;, request)
    return response


def cli_command(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            echo - str - If echo on, result includes commands and their output; 
                otherwise it will only include the commands output
            error_option - str - How the command execution should behave when 
                errors occur.
            replace - bool - If true, it tries to push the entire 
                script/commands as a replace operation
            script_file - str - The filepath of the previously downloaded CLI 
                script
            commands - str - CLI commands to execute; multiple commands can be 
                provided, one per line

    ----------------------------
    &#34;&#34;&#34;

    echo = kwargs.get(&#39;echo&#39;, None)
    error_option = kwargs.get(&#39;error_option&#39;, None)
    replace = kwargs.get(&#39;replace&#39;, None)
    script_file = kwargs.get(&#39;script_file&#39;, None)
    commands = kwargs.get(&#39;commands&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;echo&#34;: echo,
        &#34;error-option&#34;: error_option,
        &#34;replace&#34;: replace,
        &#34;script-file&#34;: script_file,
        &#34;commands&#34;: commands
    }

    response = gxutils.send_rpc(manager, &#39;cli-command&#39;, request)
    return response


def close_session(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;close-session&#39;, request)
    return response


def commit(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            confirmed - str - Requests a confirmed commit.
            confirm_timeout - int - The timeout interval for a confirmed commit.
            persist - str - This parameter is used to make a confirmed commit 
                persistent. A persistent confirmed commit is not aborted if the 
                NETCONF session terminates. The only way to abort a persistent 
                confirmed commit is to let the timer expire, or to use the 
                &lt;cancel-commit&gt; operation. The value of this parameter is a token 
                that must be given in the &#39;persist-id&#39; parameter of &lt;commit&gt; or 
                &lt;cancel-commit&gt; operations in order to confirm or cancel the 
                persistent confirmed commit. The token should be a random string.
            persist_id - str - This parameter is given in order to commit a 
                persistent confirmed commit. The value must be equal to the value 
                given in the &#39;persist&#39; parameter to the &lt;commit&gt; operation. If it 
                does not match, the operation fails with an &#39;invalid-value&#39; error.

    ----------------------------
    &#34;&#34;&#34;

    confirmed = kwargs.get(&#39;confirmed&#39;, None)
    confirm_timeout = kwargs.get(&#39;confirm_timeout&#39;, None)
    persist = kwargs.get(&#39;persist&#39;, None)
    persist_id = kwargs.get(&#39;persist_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;confirmed&#34;: confirmed,
        &#34;confirm-timeout&#34;: confirm_timeout,
        &#34;persist&#34;: persist,
        &#34;persist-id&#34;: persist_id
    }

    response = gxutils.send_rpc(manager, &#39;commit&#39;, request)
    return response


def copy_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;copy-config&#39;, request)
    return response


def create_subscription(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            stream - str - An optional parameter that indicates which stream of 
                events is of interest. If not present, then events in the default 
                NETCONF stream will be sent.
            startTime - str - A parameter used to trigger the replay feature and 
                indicates that the replay should start at the time specified. If 
                start time is not present, this is not a replay subscription.
            stopTime - str - An optional parameter used with the optional replay 
                feature to indicate the newest notifications of interest. If stop 
                time is not present, the notifications will continue until the 
                subscription is terminated. Must be used with startTime.

    ----------------------------
    &#34;&#34;&#34;

    stream = kwargs.get(&#39;stream&#39;, None)
    startTime = kwargs.get(&#39;startTime&#39;, None)
    stopTime = kwargs.get(&#39;stopTime&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;stream&#34;: stream,
        &#34;startTime&#34;: startTime,
        &#34;stopTime&#34;: stopTime
    }

    response = gxutils.send_rpc(manager, &#39;create-subscription&#39;, request)
    return response


def create_xcon(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            payload_type - str - Indicates a generic, high-level source (from) 
                client payload type of the digital XCON.
            direction - str - Indicates whether the digital XCON is 
                uni-directional (1-WAY) or bi-directional (2-WAY).
            circuit_id_suffix - str - User configured circuit ID suffix.
            label - str - User label.
            source - str - Source end-point of the xcon. Must be an existing 
                facility that can be used as a XCON end-point.
            src_parent_odu - str - Name of the High Order parent ODU where to 
                audst-create this ODU end-point.
            src_time_slots - str - List of time-slots to allocate to the 
                automatically created LO-ODU. Value can be: - omitted/empty - in 
                which case system will audst-allocate time-slots based on the 
                src-instance-id, which becomes mandatory (this is only supported for 
                non ODUflex scenarios.) - starting time-slot - system automatically 
                allocates the rest of the time-slots sequentially from this starting 
                point; will fail if those time-slots are not available - time-slot 
                list - full list of time-slots, using a comma separated list, with 
                &#39;x..y&#39; representing ranges; the total number of time-slots need to 
                match the associated payload-type (e.g. 80 time-slots for 100G 
                payload, 320 time-slots for 400G payload, etc)
            src_instance_id - int - Optional parameter on LO-ODU creation, 
                identifies the ODU within the parent/high-order ODU. If not 
                provided, it is automatically derived. Max value depends on capacity 
                of the HO-ODU and of the odu-type. (ex: for creating an ODU4 in a HO 
                ODUC8, instance can be between 1 and 8) Note: instance-id becomes 
                mandatory if time-slots are not provided.
            destination - str - Destination end-point of the xcon. Must be an 
                existing facility that can be used as a XCON end-point.
            dst_parent_odu - str - Name of the High Order parent ODU where to 
                audst-create this ODU end-point.
            dst_time_slots - str - List of time-slots to allocate to the 
                automatically created LO-ODU. Value can be: - omitted/empty - in 
                which case system will audst-allocate time-slots based on the 
                dst-instance-id, which becomes mandatory (this is only supported for 
                non ODUflex scenarios.) - starting time-slot - system automatically 
                allocates the rest of the time-slots sequentially from this starting 
                point; will fail if those time-slots are not available - time-slot 
                list - full list of time-slots, using a comma separated list, with 
                &#39;x..y&#39; representing ranges; the total number of time-slots need to 
                match the associated payload-type (e.g. 80 time-slots for 100G 
                payload, 320 time-slots for 400G payload, etc)
            dst_instance_id - int - Optional parameter on LO-ODU creation, 
                identifies the ODU within the parent/high-order ODU. If not 
                provided, it is automatically derived. Max value depends on capacity 
                of the HO-ODU and of the odu-type. (ex: for creating an ODU4 in a HO 
                ODUC8, instance can be between 1 and 8) Note: instance-id becomes 
                mandatory if time-slots are not provided.

    ----------------------------
    &#34;&#34;&#34;

    payload_type = kwargs.get(&#39;payload_type&#39;, None)
    direction = kwargs.get(&#39;direction&#39;, None)
    circuit_id_suffix = kwargs.get(&#39;circuit_id_suffix&#39;, None)
    label = kwargs.get(&#39;label&#39;, None)
    source = kwargs.get(&#39;source&#39;, None)
    src_parent_odu = kwargs.get(&#39;src_parent_odu&#39;, None)
    src_time_slots = kwargs.get(&#39;src_time_slots&#39;, None)
    src_instance_id = kwargs.get(&#39;src_instance_id&#39;, None)
    destination = kwargs.get(&#39;destination&#39;, None)
    dst_parent_odu = kwargs.get(&#39;dst_parent_odu&#39;, None)
    dst_time_slots = kwargs.get(&#39;dst_time_slots&#39;, None)
    dst_instance_id = kwargs.get(&#39;dst_instance_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;payload-type&#34;: payload_type,
        &#34;direction&#34;: direction,
        &#34;circuit-id-suffix&#34;: circuit_id_suffix,
        &#34;label&#34;: label,
        &#34;source&#34;: source,
        &#34;src-parent-odu&#34;: src_parent_odu,
        &#34;src-time-slots&#34;: src_time_slots,
        &#34;src-instance-id&#34;: src_instance_id,
        &#34;destination&#34;: destination,
        &#34;dst-parent-odu&#34;: dst_parent_odu,
        &#34;dst-time-slots&#34;: dst_time_slots,
        &#34;dst-instance-id&#34;: dst_instance_id
    }

    response = gxutils.send_rpc(manager, &#39;create-xcon&#39;, request)
    return response


def csr_gen(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            certificate_name - str - Specifies the name of the certificate to be 
                generated. Using existing name implies rotation. NOTE: When 
                importing the signed certificate at a later step, the exact same 
                certificate-name needs to be used.
            signature_hash_algorithm - str - Hash algorithm to be used. Default 
                value depends on the selected key-algorithm.
            metadata_template - str - Selects the possible sources for the CSR 
                metadata, including reusing it from an existing certificate, loading 
                from an openssl cnf file, or using a generic template which defines 
                the metadata defaults. In all cases except for &#39;from-openssl-cnf&#39;, 
                it is possible to override the metadata individual parameters by 
                providing the metadata parameters (subject, SAN, etc) explicitly.
            metadata_from_certificate - unknown - A local-certificate id to be 
                used as metadata source. Metadata details can be overridden 
                separately.
            metadata_from_cnf - str - Multi-line string input of cnf with 
                metadata. Metadata details can be overridden separately.
            subject - str - The certificate subject. The common name (CN) RDN is 
                *mandatory*. Each relative DN must have a prefix slash (/). Example 
                a minimal valid subject (contains CN only): &#39;/CN=Infinera&#39; An 
                example with all supported RDN fields: 
                &#39;/CN=InfineraRoot/C=US/ST=California/L=Sunnyvale/O=InfineraCorporation/OU=InfineraR&amp;D&#39;
                
            SAN - str - The certificate SAN (Subject Alternate Name) fields. 
                SANs are specified as Type-Value comma separated list. Valid types 
                are &#39;IP&#39;, &#39;DNS&#39; and &#39;otherName&#39;. Examples: 
                SAN=&#39;IP:127.0.0.1,DNS:localhost&#39; 
                SAN=&#39;dns:GX-10-4,otherName:1.3.6.1.4.1.21296.1.2.2.1.2;UTF8:GX-10-4&#39;
            key_usage - str - The Key Usage type(s) for the certificate. Default 
                is derived from the metadata-template parameter.
            extended_key_usage - str - The Extended Key Usage type(s) for the 
                certificate. Default is derived from the metadata-template parameter.
            key_algorithm - str - Specifies the algorithm to be used for a new 
                key pair for this CSR.
            key_from_certificate - unknown - Allows to reuse the key pair from 
                an existing local-certificate.

    ----------------------------
    &#34;&#34;&#34;

    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    signature_hash_algorithm = kwargs.get(&#39;signature_hash_algorithm&#39;, None)
    metadata_template = kwargs.get(&#39;metadata_template&#39;, None)
    metadata_from_certificate = kwargs.get(&#39;metadata_from_certificate&#39;, None)
    metadata_from_cnf = kwargs.get(&#39;metadata_from_cnf&#39;, None)
    subject = kwargs.get(&#39;subject&#39;, None)
    SAN = kwargs.get(&#39;SAN&#39;, None)
    key_usage = kwargs.get(&#39;key_usage&#39;, None)
    extended_key_usage = kwargs.get(&#39;extended_key_usage&#39;, None)
    key_algorithm = kwargs.get(&#39;key_algorithm&#39;, None)
    key_from_certificate = kwargs.get(&#39;key_from_certificate&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;certificate-name&#34;: certificate_name,
        &#34;signature-hash-algorithm&#34;: signature_hash_algorithm,
        &#34;metadata-template&#34;: metadata_template,
        &#34;metadata-from-certificate&#34;: metadata_from_certificate,
        &#34;metadata-from-cnf&#34;: metadata_from_cnf,
        &#34;subject&#34;: subject,
        &#34;SAN&#34;: SAN,
        &#34;key-usage&#34;: key_usage,
        &#34;extended-key-usage&#34;: extended_key_usage,
        &#34;key-algorithm&#34;: key_algorithm,
        &#34;key-from-certificate&#34;: key_from_certificate
    }

    response = gxutils.send_rpc(manager, &#39;csr-gen&#39;, request)
    return response


def default(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity_id - str - Instances to be defaulted.
            attribute - str - Attribute names to be defaulted. If empty, default 
                all entities&#39; attributes.

    ----------------------------
    &#34;&#34;&#34;

    entity_id = kwargs.get(&#39;entity_id&#39;, None)
    attribute = kwargs.get(&#39;attribute&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity-id&#34;: entity_id,
        &#34;attribute&#34;: attribute
    }

    response = gxutils.send_rpc(manager, &#39;default&#39;, request)
    return response


def delete_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;delete-config&#39;, request)
    return response


def delete_isk(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            key_name - unknown - Image Signing Key (ISK) name

    ----------------------------
    &#34;&#34;&#34;

    key_name = kwargs.get(&#39;key_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;key-name&#34;: key_name
    }

    response = gxutils.send_rpc(manager, &#39;delete-isk&#39;, request)
    return response


def diff(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            candidate - str - The candidate datastore configuration.

    ----------------------------
    &#34;&#34;&#34;

    candidate = kwargs.get(&#39;candidate&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;candidate&#34;: candidate
    }

    response = gxutils.send_rpc(manager, &#39;diff&#39;, request)
    return response


def disable_led(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity - str - Targets a specific entity in the system for having 
                its location led test disabled. Can be a chassis or a card.

    ----------------------------
    &#34;&#34;&#34;

    entity = kwargs.get(&#39;entity&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity&#34;: entity
    }

    response = gxutils.send_rpc(manager, &#39;disable-led&#39;, request)
    return response


def discard_changes(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;discard-changes&#39;, request)
    return response


def display_cert(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            display_type - str - Defines the requested type of display operation.
            certificate - str - The target certificate to display details or 
                trust-chain.

    ----------------------------
    &#34;&#34;&#34;

    display_type = kwargs.get(&#39;display_type&#39;, None)
    certificate = kwargs.get(&#39;certificate&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;display-type&#34;: display_type,
        &#34;certificate&#34;: certificate
    }

    response = gxutils.send_rpc(manager, &#39;display-cert&#39;, request)
    return response


def download(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for download
            passphrase - str - To decode encrypted input files.
            white_listed - bool - If true, peer-certificate does not have an 
                associated trust-chain. Else, has an associated trust-chain.
            certificate_name - str - X509v3 local/trusted/peer certificate id.
            intermediate_import - bool - Allow to import any intermediate 
                certificates present in a certificate file bundle. If 
                certificate-name is not provided, it will be auto-generated from the 
                topmost certificate Issuer CN plus a numeric suffix.
            unattended - bool - Auto prepare and auto activate file after a 
                successful download. Only some files support &#39;activation&#39;; others 
                just ignore this flag.
            async_ - bool - Download asynchronously.
            skip_secure_verification - bool - For HTTPS transfers, skip TLS 
                verification. For SCP/SFTP transfers, skip ssh known host checking. 
                If flag not set, verification is done according with current 
                security-policy.
            sanity_check_override - bool - If true, skips the sanity check 
                override when downloading a database snapshot.
            destination - str - Allows user to provide the destination for the 
                downloaded file, including directory and/or filename. This is only 
                applicable when file-type is &#39;file&#39;, representing a generic file 
                transfer. The parameter can be: - omitted: means file is downloaded 
                to the default directory with the original file-name - a file-name 
                only: uses default directory with the new file-name - a relative 
                path: uses the default directory as starting path, plus relative 
                path - an absolute path: Absolute path for the user accessible 
                directories can be used It is necessary for the user to have write 
                access to the destination path for the download to succeed. Tip: use 
                &#39;show transfer&#39; to see what is the default storage directory. For 
                generic file transfer, no further activity occurs after download, so 
                the &#39;unattended&#39; flag will be ignored.
            password - str - SFTP/SCP/FTP/HTTP/HTTPS password
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.
            db_action - str - Specify the expected database operation during 
                activating software image.
            source - str - Source of the download 
                ([sftp|scp|http|https|ftp|file]://[user@]hostname/directorypath/filename)
                
            file_server - unknown - The preconfigured file-server name.
            path - str - Path (directory and filename) of the remote file.

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    passphrase = kwargs.get(&#39;passphrase&#39;, None)
    white_listed = kwargs.get(&#39;white_listed&#39;, None)
    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    intermediate_import = kwargs.get(&#39;intermediate_import&#39;, None)
    unattended = kwargs.get(&#39;unattended&#39;, None)
    async_ = kwargs.get(&#39;async_&#39;, None)
    skip_secure_verification = kwargs.get(&#39;skip_secure_verification&#39;, None)
    sanity_check_override = kwargs.get(&#39;sanity_check_override&#39;, None)
    destination = kwargs.get(&#39;destination&#39;, None)
    password = kwargs.get(&#39;password&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)
    db_action = kwargs.get(&#39;db_action&#39;, None)
    source = kwargs.get(&#39;source&#39;, None)
    file_server = kwargs.get(&#39;file_server&#39;, None)
    path = kwargs.get(&#39;path&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;passphrase&#34;: passphrase,
        &#34;white-listed&#34;: white_listed,
        &#34;certificate-name&#34;: certificate_name,
        &#34;intermediate-import&#34;: intermediate_import,
        &#34;unattended&#34;: unattended,
        &#34;async&#34;: async_,
        &#34;skip-secure-verification&#34;: skip_secure_verification,
        &#34;sanity-check-override&#34;: sanity_check_override,
        &#34;destination&#34;: destination,
        &#34;password&#34;: password,
        &#34;db-passphrase&#34;: db_passphrase,
        &#34;db-action&#34;: db_action,
        &#34;source&#34;: source,
        &#34;file-server&#34;: file_server,
        &#34;path&#34;: path
    }

    response = gxutils.send_rpc(manager, &#39;download&#39;, request)
    return response


def edit_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            default_operation - str - The default operation to use.
            test_option - str - The test option to use.
            error_option - str - The error option to use.
            url - str - URL-based config content.

    ----------------------------
    &#34;&#34;&#34;

    default_operation = kwargs.get(&#39;default_operation&#39;, None)
    test_option = kwargs.get(&#39;test_option&#39;, None)
    error_option = kwargs.get(&#39;error_option&#39;, None)
    url = kwargs.get(&#39;url&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;default-operation&#34;: default_operation,
        &#34;test-option&#34;: test_option,
        &#34;error-option&#34;: error_option,
        &#34;url&#34;: url
    }

    response = gxutils.send_rpc(manager, &#39;edit-config&#39;, request)
    return response


def enable_led(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity - str - Targets a specific entity in the system for enabling 
                its location led test. Can be a chassis or a card.
            timeout - int - Specify the timeout, in seconds, before enable-led 
                terminates. 0 means no timeout.
            led_mode - str - Selects the led flash pattern.

    ----------------------------
    &#34;&#34;&#34;

    entity = kwargs.get(&#39;entity&#39;, None)
    timeout = kwargs.get(&#39;timeout&#39;, None)
    led_mode = kwargs.get(&#39;led_mode&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity&#34;: entity,
        &#34;timeout&#34;: timeout,
        &#34;led-mode&#34;: led_mode
    }

    response = gxutils.send_rpc(manager, &#39;enable-led&#39;, request)
    return response


def file_operation(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            operation - str - File operations to do.
            file_path - str - Current file path.
            new_file_path - str - New file path.

    ----------------------------
    &#34;&#34;&#34;

    operation = kwargs.get(&#39;operation&#39;, None)
    file_path = kwargs.get(&#39;file_path&#39;, None)
    new_file_path = kwargs.get(&#39;new_file_path&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;operation&#34;: operation,
        &#34;file-path&#34;: file_path,
        &#34;new-file-path&#34;: new_file_path
    }

    response = gxutils.send_rpc(manager, &#39;file-operation&#39;, request)
    return response


def get_conditions(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            direction - str - Direction of the condition.
            location - str - Location of the condition.
            resource - str - Existing system resource.
            resource_type - str - Type of resource.
            AID - str - Resource Access Identifier (AID). Identifies an instance 
                within a specific resource type.
            alarm_type - str - Type of alarm, based on an abbreviated code.

    ----------------------------
    &#34;&#34;&#34;

    direction = kwargs.get(&#39;direction&#39;, None)
    location = kwargs.get(&#39;location&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)
    resource_type = kwargs.get(&#39;resource_type&#39;, None)
    AID = kwargs.get(&#39;AID&#39;, None)
    alarm_type = kwargs.get(&#39;alarm_type&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;direction&#34;: direction,
        &#34;location&#34;: location,
        &#34;resource&#34;: resource,
        &#34;resource-type&#34;: resource_type,
        &#34;AID&#34;: AID,
        &#34;alarm-type&#34;: alarm_type
    }

    response = gxutils.send_rpc(manager, &#39;get-conditions&#39;, request)
    return response


def get_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;get-config&#39;, request)
    return response


def get_file(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            path_name - str - If name is a directory, display its list, if name 
                is a file, display its contents. The path can be relative to the 
                /storage directory or absolute.

    ----------------------------
    &#34;&#34;&#34;

    path_name = kwargs.get(&#39;path_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;path-name&#34;: path_name
    }

    response = gxutils.send_rpc(manager, &#39;get-file&#39;, request)
    return response


def get_log(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            log_file_name - unknown - The log file to read; must match a 
                currently configured log-file.
            start_time - str - Returns log entries starting from this timestamp. 
                If not provided, consider the oldest available logs.
            end_time - str - Returns log entries ending at this timestamp. If 
                not provided, consider all the logs until the most recent timestamp.
            number_of_entries - str - Describes the amount of log entries that 
                are to be returned.
            pattern_match - str - Allows to provide a regex that filters log 
                entries.

    ----------------------------
    &#34;&#34;&#34;

    log_file_name = kwargs.get(&#39;log_file_name&#39;, None)
    start_time = kwargs.get(&#39;start_time&#39;, None)
    end_time = kwargs.get(&#39;end_time&#39;, None)
    number_of_entries = kwargs.get(&#39;number_of_entries&#39;, None)
    pattern_match = kwargs.get(&#39;pattern_match&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;log-file-name&#34;: log_file_name,
        &#34;start-time&#34;: start_time,
        &#34;end-time&#34;: end_time,
        &#34;number-of-entries&#34;: number_of_entries,
        &#34;pattern-match&#34;: pattern_match
    }

    response = gxutils.send_rpc(manager, &#39;get-log&#39;, request)
    return response


def get_pm(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            data_type - str - Type of PM data to retrieve.
            number_of_records - int - Maximum number of records that will be 
                retrieved.
            skip_records - int - Allows user to specify a number of records that 
                will be skipped, so that the total data can be fetched in multiple 
                requests. Example: - system has 2300 PM records available - 1st 
                get-pm with (number-of-records = 1000) and (skip-records = 0); 
                result has 0..1000 records - 2nd get-pm with (number-of-records = 
                1000) and (skip-records = 1000); result has 1001..2000 records - 3nd 
                get-pm with (number-of-records = 1000) and (skip-records = 2000); 
                result has 2001..2300 records
            period - str - Time period for PM data.
            start_time - str - If provided, defines the start timestamp that 
                will be considered to filter the PM results. If not provided, the 
                oldest data timestamp will be considered.
            end_time - str - If provided, defines the end timestamp that will be 
                considered to filter the PM results. If not provided, the most 
                recent data timestamp will be considered.
            start_bin - int - If provided, defines the start bin number that 
                will be considered to filter the PM results. If not provided, the 
                smallest bin number (most recent data) will be considered.
            end_bin - int - If provided, defines the end bin number that will be 
                considered to filter the PM results. If not provided, the largest 
                available bin number (oldest data) will be considered.
            filter_list - list - List of:
                filter-id - int - Identifier for each filter, has no specific meaning.
                resource - str - Existing system resource.
                resource-type - str - Type of resource.
                AID - str - Resource Access Identifier (AID). Identifies an instance 
                    within a specific resource type.
                parameter - str - PM parameter identifier (can be a counter or a 
                    gauge).
                direction - str - PM parameter direction.
                location - str - PM parameter location.

    ----------------------------
    &#34;&#34;&#34;

    data_type = kwargs.get(&#39;data_type&#39;, None)
    number_of_records = kwargs.get(&#39;number_of_records&#39;, None)
    skip_records = kwargs.get(&#39;skip_records&#39;, None)
    period = kwargs.get(&#39;period&#39;, None)
    start_time = kwargs.get(&#39;start_time&#39;, None)
    end_time = kwargs.get(&#39;end_time&#39;, None)
    start_bin = kwargs.get(&#39;start_bin&#39;, None)
    end_bin = kwargs.get(&#39;end_bin&#39;, None)
    filter_list = kwargs.get(&#39;filter_list&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;data-type&#34;: data_type,
        &#34;number-of-records&#34;: number_of_records,
        &#34;skip-records&#34;: skip_records,
        &#34;period&#34;: period,
        &#34;start-time&#34;: start_time,
        &#34;end-time&#34;: end_time,
        &#34;start-bin&#34;: start_bin,
        &#34;end-bin&#34;: end_bin,
        &#34;filter&#34;: filter_list
    }

    response = gxutils.send_rpc(manager, &#39;get-pm&#39;, request)
    return response


def get_schema(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            identifier - str - Identifier for the schema list entry.
            version - str - Version of the schema requested. If this parameter 
                is not present, and more than one version of the schema exists on 
                the server, a &#39;data-not-unique&#39; error is returned, as described above.
            format - str - The data modeling language of the schema. If this 
                parameter is not present, and more than one formats of the schema 
                exists on the server, a &#39;data-not-unique&#39; error is returned, as 
                described above.

    ----------------------------
    &#34;&#34;&#34;

    identifier = kwargs.get(&#39;identifier&#39;, None)
    version = kwargs.get(&#39;version&#39;, None)
    format = kwargs.get(&#39;format&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;identifier&#34;: identifier,
        &#34;version&#34;: version,
        &#34;format&#34;: format
    }

    response = gxutils.send_rpc(manager, &#39;get-schema&#39;, request)
    return response


def get_script(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            list_scripts - str - List all existing scripts.
            script_name - str - Get the content of an existing script. The 
                script name is a relative path to the script directory.

    ----------------------------
    &#34;&#34;&#34;

    list_scripts = kwargs.get(&#39;list_scripts&#39;, None)
    script_name = kwargs.get(&#39;script_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;list-scripts&#34;: list_scripts,
        &#34;script-name&#34;: script_name
    }

    response = gxutils.send_rpc(manager, &#39;get-script&#39;, request)
    return response


def get(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;get&#39;, request)
    return response


def import_certificate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Certificate types available for import.
            certificate_name - str - X509v3 local/peer/trusted certificate ID.
            certificate_pem - str - Certificate bytes or certificates bundle in 
                PEM format.
            passphrase - str - To decode encrypted input certificates.
            intermediate_import - bool - Allow to import any intermediate 
                certificates present in a PEM string bundle. If certificate-name is 
                not provided, it will be auto-generated from the topmost certificate 
                issuer CN plus a numeric suffix.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    certificate_pem = kwargs.get(&#39;certificate_pem&#39;, None)
    passphrase = kwargs.get(&#39;passphrase&#39;, None)
    intermediate_import = kwargs.get(&#39;intermediate_import&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;certificate-name&#34;: certificate_name,
        &#34;certificate-pem&#34;: certificate_pem,
        &#34;passphrase&#34;: passphrase,
        &#34;intermediate-import&#34;: intermediate_import
    }

    response = gxutils.send_rpc(manager, &#39;import-certificate&#39;, request)
    return response


def install_krp(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            krp_name - str - Key replacement package name

    ----------------------------
    &#34;&#34;&#34;

    krp_name = kwargs.get(&#39;krp_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;krp-name&#34;: krp_name
    }

    response = gxutils.send_rpc(manager, &#39;install-krp&#39;, request)
    return response


def kill_session(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            session_id - unknown - Identifier of the session that will be killed.

    ----------------------------
    &#34;&#34;&#34;

    session_id = kwargs.get(&#39;session_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;session-id&#34;: session_id
    }

    response = gxutils.send_rpc(manager, &#39;kill-session&#39;, request)
    return response


def lock(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;lock&#39;, request)
    return response


def manual_switchover(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            resource - str - Active controller card to switchover.

    ----------------------------
    &#34;&#34;&#34;

    resource = kwargs.get(&#39;resource&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;resource&#34;: resource
    }

    response = gxutils.send_rpc(manager, &#39;manual-switchover&#39;, request)
    return response


def no_op(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;no-op&#39;, request)
    return response


def password(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            old_password - str - The current password.
            new_password - str - The new password.

    ----------------------------
    &#34;&#34;&#34;

    old_password = kwargs.get(&#39;old_password&#39;, None)
    new_password = kwargs.get(&#39;new_password&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;old-password&#34;: old_password,
        &#34;new-password&#34;: new_password
    }

    response = gxutils.send_rpc(manager, &#39;password&#39;, request)
    return response


def ping(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ping_count - int - Stops after sending &#39;count&#39; ECHO_REQUEST packets.
            ping_timeout - int - Specify the timeout, in seconds, before ping 
                exits.
            ping_pktsize - int - Specifies the number of bytes to be sent. 
                Default is 56, exclusive of headers.
            ping_dest - str - IP address or FQDN of the destination node.
            ping_interface - unknown - Specify source interface name
            ping_vrf - str - VRF to use. If not provided, defaults to MGMT.

    ----------------------------
    &#34;&#34;&#34;

    ping_count = kwargs.get(&#39;ping_count&#39;, None)
    ping_timeout = kwargs.get(&#39;ping_timeout&#39;, None)
    ping_pktsize = kwargs.get(&#39;ping_pktsize&#39;, None)
    ping_dest = kwargs.get(&#39;ping_dest&#39;, None)
    ping_interface = kwargs.get(&#39;ping_interface&#39;, None)
    ping_vrf = kwargs.get(&#39;ping_vrf&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ping-count&#34;: ping_count,
        &#34;ping-timeout&#34;: ping_timeout,
        &#34;ping-pktsize&#34;: ping_pktsize,
        &#34;ping-dest&#34;: ping_dest,
        &#34;ping-interface&#34;: ping_interface,
        &#34;ping-vrf&#34;: ping_vrf
    }

    response = gxutils.send_rpc(manager, &#39;ping&#39;, request)
    return response


def prepare_upgrade(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            option - str - Predefined options available for prepare-upgrade
            manifest - unknown - manifest to be prepared for upgrade
            ignore_precheck_failures - bool - Ignore validation failures.
            unattended - bool - Auto activate software after prepare upgrade.
            db_action - str - Specify the expected database operation during 
                activating software image.

    ----------------------------
    &#34;&#34;&#34;

    option = kwargs.get(&#39;option&#39;, None)
    manifest = kwargs.get(&#39;manifest&#39;, None)
    ignore_precheck_failures = kwargs.get(&#39;ignore_precheck_failures&#39;, None)
    unattended = kwargs.get(&#39;unattended&#39;, None)
    db_action = kwargs.get(&#39;db_action&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;option&#34;: option,
        &#34;manifest&#34;: manifest,
        &#34;ignore-precheck-failures&#34;: ignore_precheck_failures,
        &#34;unattended&#34;: unattended,
        &#34;db-action&#34;: db_action
    }

    response = gxutils.send_rpc(manager, &#39;prepare-upgrade&#39;, request)
    return response


def protection_switch(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            protection_group - str - The target of the switch command.
            operation_type - str - The type of protection switch command
            switch_target - str - The target of the switch command, which is not 
                needed for release and lockout operation.

    ----------------------------
    &#34;&#34;&#34;

    protection_group = kwargs.get(&#39;protection_group&#39;, None)
    operation_type = kwargs.get(&#39;operation_type&#39;, None)
    switch_target = kwargs.get(&#39;switch_target&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;protection-group&#34;: protection_group,
        &#34;operation-type&#34;: operation_type,
        &#34;switch-target&#34;: switch_target
    }

    response = gxutils.send_rpc(manager, &#39;protection-switch&#39;, request)
    return response


def re_auth(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ikev2_peer - str - A reference to the IKE peer object (IKE SA).

    ----------------------------
    &#34;&#34;&#34;

    ikev2_peer = kwargs.get(&#39;ikev2_peer&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ikev2-peer&#34;: ikev2_peer
    }

    response = gxutils.send_rpc(manager, &#39;re-auth&#39;, request)
    return response


def re_key(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ipsec_security_association - str - Points to IPsec SPD entry object 
                (Child SA).
            ikev2_peer - str - A reference to the IKE peer object (IKE SA).
            secure_entity - str - Points to secure entity object (Child SA).

    ----------------------------
    &#34;&#34;&#34;

    ipsec_security_association = kwargs.get(&#39;ipsec_security_association&#39;, None)
    ikev2_peer = kwargs.get(&#39;ikev2_peer&#39;, None)
    secure_entity = kwargs.get(&#39;secure_entity&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ipsec-security-association&#34;: ipsec_security_association,
        &#34;ikev2-peer&#34;: ikev2_peer,
        &#34;secure-entity&#34;: secure_entity
    }

    response = gxutils.send_rpc(manager, &#39;re-key&#39;, request)
    return response


def restart(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            resource - str - Resource to restart. If not provided, by default 
                restarts the node controller.
            type - str - Restart type
            sub_component - str - Allows to target a card sub-component to 
                restart.

    ----------------------------
    &#34;&#34;&#34;

    resource = kwargs.get(&#39;resource&#39;, None)
    type = kwargs.get(&#39;type&#39;, None)
    sub_component = kwargs.get(&#39;sub_component&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;resource&#34;: resource,
        &#34;type&#34;: type,
        &#34;sub-component&#34;: sub_component
    }

    response = gxutils.send_rpc(manager, &#39;restart&#39;, request)
    return response


def run_script(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            script_name - str - Script absolute or relative path from the script 
                directory.
            arguments - str - Optional arguments to the script.

    ----------------------------
    &#34;&#34;&#34;

    script_name = kwargs.get(&#39;script_name&#39;, None)
    arguments = kwargs.get(&#39;arguments&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;script-name&#34;: script_name,
        &#34;arguments&#34;: arguments
    }

    response = gxutils.send_rpc(manager, &#39;run-script&#39;, request)
    return response


def run_task(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            task_name - unknown - The task name to be executed.

    ----------------------------
    &#34;&#34;&#34;

    task_name = kwargs.get(&#39;task_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;task-name&#34;: task_name
    }

    response = gxutils.send_rpc(manager, &#39;run-task&#39;, request)
    return response


def set_alarm_state(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            state - str - Alarm state.
            acknowledge_text - str - Optional text that will be stored in the 
                alarm.
            all_alarms - str - Acknowledge all currently raised alarms.

    ----------------------------
    &#34;&#34;&#34;

    state = kwargs.get(&#39;state&#39;, None)
    acknowledge_text = kwargs.get(&#39;acknowledge_text&#39;, None)
    all_alarms = kwargs.get(&#39;all_alarms&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;state&#34;: state,
        &#34;acknowledge-text&#34;: acknowledge_text,
        &#34;all-alarms&#34;: all_alarms
    }

    response = gxutils.send_rpc(manager, &#39;set-alarm-state&#39;, request)
    return response


def set_time(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            new_time - str - Time to set in the system

    ----------------------------
    &#34;&#34;&#34;

    new_time = kwargs.get(&#39;new_time&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;new-time&#34;: new_time
    }

    response = gxutils.send_rpc(manager, &#39;set-time&#39;, request)
    return response


def simulate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            trigger - str - The alarm event trigger to simulate.
            holder_AID - str - AID of the equipment holder (slot or port) where 
                the equipment will be simulated.
            type - str - The type of the equipment to be simulated.
            subtype - str - The subtype of the equipment to be simulated.
            alarmed_entity - str - The entity affected by the alarm; if ommitted 
                when clearing alarms, all simulated alarms are cleared.
            alarm_type - str - The alarm type to be simulated; if ommitted when 
                clearing alarms, all simulated alarms are cleared.
            alarm_direction - str - The direction of the simulated alarm. If 
                ommitted, system selects direction automatically.
            alarm_location - str - The location of the simulated alarm. If 
                ommitted, system selects location automatically.

    ----------------------------
    &#34;&#34;&#34;

    trigger = kwargs.get(&#39;trigger&#39;, None)
    holder_AID = kwargs.get(&#39;holder_AID&#39;, None)
    type = kwargs.get(&#39;type&#39;, None)
    subtype = kwargs.get(&#39;subtype&#39;, None)
    alarmed_entity = kwargs.get(&#39;alarmed_entity&#39;, None)
    alarm_type = kwargs.get(&#39;alarm_type&#39;, None)
    alarm_direction = kwargs.get(&#39;alarm_direction&#39;, None)
    alarm_location = kwargs.get(&#39;alarm_location&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;trigger&#34;: trigger,
        &#34;holder-AID&#34;: holder_AID,
        &#34;type&#34;: type,
        &#34;subtype&#34;: subtype,
        &#34;alarmed-entity&#34;: alarmed_entity,
        &#34;alarm-type&#34;: alarm_type,
        &#34;alarm-direction&#34;: alarm_direction,
        &#34;alarm-location&#34;: alarm_location
    }

    response = gxutils.send_rpc(manager, &#39;simulate&#39;, request)
    return response


def ssh_keygen(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            key_length - str - Strength of the key used for regenerating the 
                private-public key pair
            key_type - str - Type of key to generate
            key_label - str - Label associated with the key. If no value 
                provided, label will be the value of ne-id

    ----------------------------
    &#34;&#34;&#34;

    key_length = kwargs.get(&#39;key_length&#39;, None)
    key_type = kwargs.get(&#39;key_type&#39;, None)
    key_label = kwargs.get(&#39;key_label&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;key-length&#34;: key_length,
        &#34;key-type&#34;: key_type,
        &#34;key-label&#34;: key_label
    }

    response = gxutils.send_rpc(manager, &#39;ssh-keygen&#39;, request)
    return response


def take_snapshot(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Location where the snapshot will be stored.
            db_instance - str - Target db-instance name which will hold the DB 
                snapshot.
            description - str - Optional description for this DB snapshot.
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    db_instance = kwargs.get(&#39;db_instance&#39;, None)
    description = kwargs.get(&#39;description&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;db-instance&#34;: db_instance,
        &#34;description&#34;: description,
        &#34;db-passphrase&#34;: db_passphrase
    }

    response = gxutils.send_rpc(manager, &#39;take-snapshot&#39;, request)
    return response


def traceroute(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            tr_hopcnt - int - Specifies the maximum number of hops (max 
                time-to-live value) traceroute will probe. The default is 10.
            tr_timeout - int - Specify the timeout, in seconds, before trace 
                route exits.
            tr_dest - str - IPv4/v6 address or FQDN of the destination node.
            tr_pktsize - int - Specifies the total size of the probing packet 
                (default 60 bytes for IPv4).
            tr_interface - unknown - Specify source interface name
            tr_vrf - str - VRF to use. If not provided, defaults to MGMT.

    ----------------------------
    &#34;&#34;&#34;

    tr_hopcnt = kwargs.get(&#39;tr_hopcnt&#39;, None)
    tr_timeout = kwargs.get(&#39;tr_timeout&#39;, None)
    tr_dest = kwargs.get(&#39;tr_dest&#39;, None)
    tr_pktsize = kwargs.get(&#39;tr_pktsize&#39;, None)
    tr_interface = kwargs.get(&#39;tr_interface&#39;, None)
    tr_vrf = kwargs.get(&#39;tr_vrf&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;tr-hopcnt&#34;: tr_hopcnt,
        &#34;tr-timeout&#34;: tr_timeout,
        &#34;tr-dest&#34;: tr_dest,
        &#34;tr-pktsize&#34;: tr_pktsize,
        &#34;tr-interface&#34;: tr_interface,
        &#34;tr-vrf&#34;: tr_vrf
    }

    response = gxutils.send_rpc(manager, &#39;traceroute&#39;, request)
    return response


def unlock(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;unlock&#39;, request)
    return response


def upload(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for upload
            source - str - Allows user to provide the source for the file to be 
                uploaded, including directory and/or filename. This is only 
                applicable when file-type is &#39;file&#39;, representing a generic file 
                transfer. Can be a path relative to the default user directory, or 
                an absolute path - as long as user has access to the target file.
            async_ - bool - Uploads asynchronously.
            skip_secure_verification - bool - For HTTPS transfers, skip TLS 
                verification. For SCP/SFTP transfers, skip ssh known host checking. 
                If flag not set, verification is done according with current 
                security-policy.
            debug_entity - str - Targets a specific entity in the system for 
                having its Logs to be collected. Can be a chassis or a card
            password - str - SFTP/SCP/FTP/HTTP/HTTPS password
            start_time - str - Start time from where the logs should be 
                collected. It can be a timestamp or a time interval from the actual 
                time (now). If empty all log history is selected
            db_instance - str - Selected DB instance
            optional_content - str - List of files to be included for debug-log 
                upload.
            log_file_list - unknown - List of log files to be uploaded. If empty 
                all available logs are selected.
            period - str - Time period for PM data.
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.
            destination - str - Destination of the upload 
                ([sftp|scp|ftp|https|http|file]://[user@]hostname/directorypath/filename)
                
            file_server - unknown - The preconfigured file-server name.
            path - str - Path (directory and filename) to be used in the remote 
                file-server. If not provided, the file-server initial-path is used, 
                with system defined filename. If the path targets a directory (e.g. 
                /path/ ), the filename is dynamically generated. Otherwise, the user 
                defined filename may use some placeholders %t and %m (representing 
                timestamp and ne-name respectively).

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    source = kwargs.get(&#39;source&#39;, None)
    async_ = kwargs.get(&#39;async_&#39;, None)
    skip_secure_verification = kwargs.get(&#39;skip_secure_verification&#39;, None)
    debug_entity = kwargs.get(&#39;debug_entity&#39;, None)
    password = kwargs.get(&#39;password&#39;, None)
    start_time = kwargs.get(&#39;start_time&#39;, None)
    db_instance = kwargs.get(&#39;db_instance&#39;, None)
    optional_content = kwargs.get(&#39;optional_content&#39;, None)
    log_file_list = kwargs.get(&#39;log_file_list&#39;, None)
    period = kwargs.get(&#39;period&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)
    destination = kwargs.get(&#39;destination&#39;, None)
    file_server = kwargs.get(&#39;file_server&#39;, None)
    path = kwargs.get(&#39;path&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;source&#34;: source,
        &#34;async&#34;: async_,
        &#34;skip-secure-verification&#34;: skip_secure_verification,
        &#34;debug-entity&#34;: debug_entity,
        &#34;password&#34;: password,
        &#34;start-time&#34;: start_time,
        &#34;db-instance&#34;: db_instance,
        &#34;optional-content&#34;: optional_content,
        &#34;log-file-list&#34;: log_file_list,
        &#34;period&#34;: period,
        &#34;db-passphrase&#34;: db_passphrase,
        &#34;destination&#34;: destination,
        &#34;file-server&#34;: file_server,
        &#34;path&#34;: path
    }

    response = gxutils.send_rpc(manager, &#39;upload&#39;, request)
    return response


def validate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;validate&#39;, request)
    return response</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gx_rpcs.activate_file"><code class="name flex">
<span>def <span class="ident">activate_file</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    filetype - str - Predefined filetype available for upload
    label - str - Label to be activated
    db_instance - str - Database instance name to activate.
    sanity_check_override - bool - Allows user to skip the 
        database/swimage sanity check.
    db_action - str - Specify the expected database operation during 
        activating software image.
    db_passphrase - str - Passphrase used for encrypting and decrypting 
        DB snapshots. For each command associated with DB snapshots (backup, 
        restore, etc), this db-passphrase will be used, except when it is 
        directly provided in each command. Automatic DB snapshots will not 
        be enabled until this parameter is set.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def activate_file(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for upload
            label - str - Label to be activated
            db_instance - str - Database instance name to activate.
            sanity_check_override - bool - Allows user to skip the 
                database/swimage sanity check.
            db_action - str - Specify the expected database operation during 
                activating software image.
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    label = kwargs.get(&#39;label&#39;, None)
    db_instance = kwargs.get(&#39;db_instance&#39;, None)
    sanity_check_override = kwargs.get(&#39;sanity_check_override&#39;, None)
    db_action = kwargs.get(&#39;db_action&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;label&#34;: label,
        &#34;db-instance&#34;: db_instance,
        &#34;sanity-check-override&#34;: sanity_check_override,
        &#34;db-action&#34;: db_action,
        &#34;db-passphrase&#34;: db_passphrase
    }

    response = gxutils.send_rpc(manager, &#39;activate-file&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.activate_fw"><code class="name flex">
<span>def <span class="ident">activate_fw</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    fw_image_name - unknown - FW file name
    resource - str - List of equipment to be activated.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def activate_fw(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            fw_image_name - unknown - FW file name
            resource - str - List of equipment to be activated.

    ----------------------------
    &#34;&#34;&#34;

    fw_image_name = kwargs.get(&#39;fw_image_name&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;fw-image-name&#34;: fw_image_name,
        &#34;resource&#34;: resource
    }

    response = gxutils.send_rpc(manager, &#39;activate-fw&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.appctl"><code class="name flex">
<span>def <span class="ident">appctl</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    command - str - Application control commands.
    app_name - unknown - Third party app name.
    target - str - Entire system or chassis/card AID.
    parameters - str - Optional parameters to be passed in the command.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appctl(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            command - str - Application control commands.
            app_name - unknown - Third party app name.
            target - str - Entire system or chassis/card AID.
            parameters - str - Optional parameters to be passed in the command.

    ----------------------------
    &#34;&#34;&#34;

    command = kwargs.get(&#39;command&#39;, None)
    app_name = kwargs.get(&#39;app_name&#39;, None)
    target = kwargs.get(&#39;target&#39;, None)
    parameters = kwargs.get(&#39;parameters&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;command&#34;: command,
        &#34;app-name&#34;: app_name,
        &#34;target&#34;: target,
        &#34;parameters&#34;: parameters
    }

    response = gxutils.send_rpc(manager, &#39;appctl&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.apply_template"><code class="name flex">
<span>def <span class="ident">apply_template</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    template_type - str - The type of template to apply. Other 
        parameters may be required depending on the template type.
    applicable_tom - str - List of TOMs to which to apply 
        serdes-templates against. If not provided (e.g. list is empty), all 
        system TOMs will be considered for application.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_template(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            template_type - str - The type of template to apply. Other 
                parameters may be required depending on the template type.
            applicable_tom - str - List of TOMs to which to apply 
                serdes-templates against. If not provided (e.g. list is empty), all 
                system TOMs will be considered for application.

    ----------------------------
    &#34;&#34;&#34;

    template_type = kwargs.get(&#39;template_type&#39;, None)
    applicable_tom = kwargs.get(&#39;applicable_tom&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;template-type&#34;: template_type,
        &#34;applicable-tom&#34;: applicable_tom
    }

    response = gxutils.send_rpc(manager, &#39;apply-template&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.call_home"><code class="name flex">
<span>def <span class="ident">call_home</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    dial_out_server_name - unknown - The dial-out-server to connect to.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_home(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            dial_out_server_name - unknown - The dial-out-server to connect to.

    ----------------------------
    &#34;&#34;&#34;

    dial_out_server_name = kwargs.get(&#39;dial_out_server_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;dial-out-server-name&#34;: dial_out_server_name
    }

    response = gxutils.send_rpc(manager, &#39;call-home&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.cancel_commit"><code class="name flex">
<span>def <span class="ident">cancel_commit</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    persist_id - str - This parameter is given in order to cancel a 
        persistent confirmed commit. The value must be equal to the value 
        given in the 'persist' parameter to the &lt;commit&gt; operation. If it 
        does not match, the operation fails with an 'invalid-value' error.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_commit(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            persist_id - str - This parameter is given in order to cancel a 
                persistent confirmed commit. The value must be equal to the value 
                given in the &#39;persist&#39; parameter to the &lt;commit&gt; operation. If it 
                does not match, the operation fails with an &#39;invalid-value&#39; error.

    ----------------------------
    &#34;&#34;&#34;

    persist_id = kwargs.get(&#39;persist_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;persist-id&#34;: persist_id
    }

    response = gxutils.send_rpc(manager, &#39;cancel-commit&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.cancel_upgrade"><code class="name flex">
<span>def <span class="ident">cancel_upgrade</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel_upgrade(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;cancel-upgrade&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.cert_gen"><code class="name flex">
<span>def <span class="ident">cert_gen</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    certificate_name - str - Specifies the name of the certificate to be 
        generated.
    days - int - Number of days a certificate is valid for.
    org_name - str - Organization Name.
    common_name - str - IP or hostname to identify the server.
    subject - str - The full certificate subject name
    auto_install - bool - Auto-assign certificate to any 
        secure-application without active certificate.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cert_gen(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            certificate_name - str - Specifies the name of the certificate to be 
                generated.
            days - int - Number of days a certificate is valid for.
            org_name - str - Organization Name.
            common_name - str - IP or hostname to identify the server.
            subject - str - The full certificate subject name
            auto_install - bool - Auto-assign certificate to any 
                secure-application without active certificate.

    ----------------------------
    &#34;&#34;&#34;

    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    days = kwargs.get(&#39;days&#39;, None)
    org_name = kwargs.get(&#39;org_name&#39;, None)
    common_name = kwargs.get(&#39;common_name&#39;, None)
    subject = kwargs.get(&#39;subject&#39;, None)
    auto_install = kwargs.get(&#39;auto_install&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;certificate-name&#34;: certificate_name,
        &#34;days&#34;: days,
        &#34;org-name&#34;: org_name,
        &#34;common-name&#34;: common_name,
        &#34;subject&#34;: subject,
        &#34;auto-install&#34;: auto_install
    }

    response = gxutils.send_rpc(manager, &#39;cert-gen&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.change_ztp_mode"><code class="name flex">
<span>def <span class="ident">change_ztp_mode</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    ztp_mode - str - Selects new ztp mode.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_ztp_mode(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ztp_mode - str - Selects new ztp mode.

    ----------------------------
    &#34;&#34;&#34;

    ztp_mode = kwargs.get(&#39;ztp_mode&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ztp-mode&#34;: ztp_mode
    }

    response = gxutils.send_rpc(manager, &#39;change-ztp-mode&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_alarm"><code class="name flex">
<span>def <span class="ident">clear_alarm</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    alarm_type - unknown - Type of alarm to be cleared. Note: only some 
        alarms are eligible to be cleared using this operation; see 
        alarm-inventory/can-be-cleared-by-user for details.
    resource - unknown - Resource of alarm to be cleared. May be one or 
        more resources assocaited with the provided alarm-type.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_alarm(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            alarm_type - unknown - Type of alarm to be cleared. Note: only some 
                alarms are eligible to be cleared using this operation; see 
                alarm-inventory/can-be-cleared-by-user for details.
            resource - unknown - Resource of alarm to be cleared. May be one or 
                more resources assocaited with the provided alarm-type.

    ----------------------------
    &#34;&#34;&#34;

    alarm_type = kwargs.get(&#39;alarm_type&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;alarm-type&#34;: alarm_type,
        &#34;resource&#34;: resource
    }

    response = gxutils.send_rpc(manager, &#39;clear-alarm&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_app"><code class="name flex">
<span>def <span class="ident">clear_app</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    app_name - unknown - Third party app name.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_app(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            app_name - unknown - Third party app name.

    ----------------------------
    &#34;&#34;&#34;

    app_name = kwargs.get(&#39;app_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;app-name&#34;: app_name
    }

    response = gxutils.send_rpc(manager, &#39;clear-app&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_certificate"><code class="name flex">
<span>def <span class="ident">clear_certificate</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    type - str - Defines the type of 'clear certificate' that the system 
        must do.
    id - str - Foreign Key pointing to the id of the certificate to 
        delete.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_certificate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Defines the type of &#39;clear certificate&#39; that the system 
                must do.
            id - str - Foreign Key pointing to the id of the certificate to 
                delete.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    id = kwargs.get(&#39;id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;id&#34;: id
    }

    response = gxutils.send_rpc(manager, &#39;clear-certificate&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_crl"><code class="name flex">
<span>def <span class="ident">clear_crl</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    clear_target - str - Defines the target CRL(s) of the clear operation.
    crl_name - unknown - Name of the CRL to delete.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_crl(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            clear_target - str - Defines the target CRL(s) of the clear operation.
            crl_name - unknown - Name of the CRL to delete.

    ----------------------------
    &#34;&#34;&#34;

    clear_target = kwargs.get(&#39;clear_target&#39;, None)
    crl_name = kwargs.get(&#39;crl_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;clear-target&#34;: clear_target,
        &#34;crl-name&#34;: crl_name
    }

    response = gxutils.send_rpc(manager, &#39;clear-crl&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_database"><code class="name flex">
<span>def <span class="ident">clear_database</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    clear_type - str - Defines the type of 'clear database' that the 
        system must do.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_database(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            clear_type - str - Defines the type of &#39;clear database&#39; that the 
                system must do.

    ----------------------------
    &#34;&#34;&#34;

    clear_type = kwargs.get(&#39;clear_type&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;clear-type&#34;: clear_type
    }

    response = gxutils.send_rpc(manager, &#39;clear-database&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_diagnostics"><code class="name flex">
<span>def <span class="ident">clear_diagnostics</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    entity_id - str - Target entity for the command. Must exist.
    test_signal_direction - str - The test signal direction. If not 
        specified, the counter for the enabled direction would be cleared.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_diagnostics(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity_id - str - Target entity for the command. Must exist.
            test_signal_direction - str - The test signal direction. If not 
                specified, the counter for the enabled direction would be cleared.

    ----------------------------
    &#34;&#34;&#34;

    entity_id = kwargs.get(&#39;entity_id&#39;, None)
    test_signal_direction = kwargs.get(&#39;test_signal_direction&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity-id&#34;: entity_id,
        &#34;test-signal-direction&#34;: test_signal_direction
    }

    response = gxutils.send_rpc(manager, &#39;clear-diagnostics&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_file"><code class="name flex">
<span>def <span class="ident">clear_file</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    filetype - str - Predefined filetype available for clearing the file
    target_file - str - Filepath of the file to be deleted
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_file(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for clearing the file
            target_file - str - Filepath of the file to be deleted

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    target_file = kwargs.get(&#39;target_file&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;target-file&#34;: target_file
    }

    response = gxutils.send_rpc(manager, &#39;clear-file&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_log"><code class="name flex">
<span>def <span class="ident">clear_log</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    log_file_name - unknown - The log file to clear; file will still 
        exist, but with empty content.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_log(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            log_file_name - unknown - The log file to clear; file will still 
                exist, but with empty content.

    ----------------------------
    &#34;&#34;&#34;

    log_file_name = kwargs.get(&#39;log_file_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;log-file-name&#34;: log_file_name
    }

    response = gxutils.send_rpc(manager, &#39;clear-log&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_ospf_instance"><code class="name flex">
<span>def <span class="ident">clear_ospf_instance</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    instance - unknown - OSPF protocol instance which need to be 
        re-started.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_ospf_instance(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            instance - unknown - OSPF protocol instance which need to be 
                re-started.

    ----------------------------
    &#34;&#34;&#34;

    instance = kwargs.get(&#39;instance&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;instance&#34;: instance
    }

    response = gxutils.send_rpc(manager, &#39;clear-ospf-instance&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_pm"><code class="name flex">
<span>def <span class="ident">clear_pm</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    data_type - str - Type of PM data to clear.
    period - str - Time period for PM data.
    direction - str - PM parameter direction.
    location - str - PM parameter location.
    resource - str - Existing system resource.
    resource_type - str - Type of resource.
    AID - str - Resource Access Identifier (AID). Identifies an instance 
        within a specific resource type.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_pm(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            data_type - str - Type of PM data to clear.
            period - str - Time period for PM data.
            direction - str - PM parameter direction.
            location - str - PM parameter location.
            resource - str - Existing system resource.
            resource_type - str - Type of resource.
            AID - str - Resource Access Identifier (AID). Identifies an instance 
                within a specific resource type.

    ----------------------------
    &#34;&#34;&#34;

    data_type = kwargs.get(&#39;data_type&#39;, None)
    period = kwargs.get(&#39;period&#39;, None)
    direction = kwargs.get(&#39;direction&#39;, None)
    location = kwargs.get(&#39;location&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)
    resource_type = kwargs.get(&#39;resource_type&#39;, None)
    AID = kwargs.get(&#39;AID&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;data-type&#34;: data_type,
        &#34;period&#34;: period,
        &#34;direction&#34;: direction,
        &#34;location&#34;: location,
        &#34;resource&#34;: resource,
        &#34;resource-type&#34;: resource_type,
        &#34;AID&#34;: AID
    }

    response = gxutils.send_rpc(manager, &#39;clear-pm&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_recover_mode"><code class="name flex">
<span>def <span class="ident">clear_recover_mode</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_recover_mode(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;clear-recover-mode&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_system"><code class="name flex">
<span>def <span class="ident">clear_system</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    type - str - Clear system type.
    target - str - Entire system (main controller chassis) or specific 
        chassis/card AID.
    restart_behavior - str - Action to do after the clean operation.
    action - str - Action to clean the partition.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_system(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Clear system type.
            target - str - Entire system (main controller chassis) or specific 
                chassis/card AID.
            restart_behavior - str - Action to do after the clean operation.
            action - str - Action to clean the partition.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    target = kwargs.get(&#39;target&#39;, None)
    restart_behavior = kwargs.get(&#39;restart_behavior&#39;, None)
    action = kwargs.get(&#39;action&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;target&#34;: target,
        &#34;restart-behavior&#34;: restart_behavior,
        &#34;action&#34;: action
    }

    response = gxutils.send_rpc(manager, &#39;clear-system&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.clear_topology"><code class="name flex">
<span>def <span class="ident">clear_topology</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    target - str - Target instance to be cleared. May be a 
        lldp-neighbor, a carrier-neighbor or a lldp-port-statistics instance.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_topology(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            target - str - Target instance to be cleared. May be a 
                lldp-neighbor, a carrier-neighbor or a lldp-port-statistics instance.

    ----------------------------
    &#34;&#34;&#34;

    target = kwargs.get(&#39;target&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;target&#34;: target
    }

    response = gxutils.send_rpc(manager, &#39;clear-topology&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.cli_command"><code class="name flex">
<span>def <span class="ident">cli_command</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    echo - str - If echo on, result includes commands and their output; 
        otherwise it will only include the commands output
    error_option - str - How the command execution should behave when 
        errors occur.
    replace - bool - If true, it tries to push the entire 
        script/commands as a replace operation
    script_file - str - The filepath of the previously downloaded CLI 
        script
    commands - str - CLI commands to execute; multiple commands can be 
        provided, one per line
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cli_command(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            echo - str - If echo on, result includes commands and their output; 
                otherwise it will only include the commands output
            error_option - str - How the command execution should behave when 
                errors occur.
            replace - bool - If true, it tries to push the entire 
                script/commands as a replace operation
            script_file - str - The filepath of the previously downloaded CLI 
                script
            commands - str - CLI commands to execute; multiple commands can be 
                provided, one per line

    ----------------------------
    &#34;&#34;&#34;

    echo = kwargs.get(&#39;echo&#39;, None)
    error_option = kwargs.get(&#39;error_option&#39;, None)
    replace = kwargs.get(&#39;replace&#39;, None)
    script_file = kwargs.get(&#39;script_file&#39;, None)
    commands = kwargs.get(&#39;commands&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;echo&#34;: echo,
        &#34;error-option&#34;: error_option,
        &#34;replace&#34;: replace,
        &#34;script-file&#34;: script_file,
        &#34;commands&#34;: commands
    }

    response = gxutils.send_rpc(manager, &#39;cli-command&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.close_session"><code class="name flex">
<span>def <span class="ident">close_session</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_session(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;close-session&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    confirmed - str - Requests a confirmed commit.
    confirm_timeout - int - The timeout interval for a confirmed commit.
    persist - str - This parameter is used to make a confirmed commit 
        persistent. A persistent confirmed commit is not aborted if the 
        NETCONF session terminates. The only way to abort a persistent 
        confirmed commit is to let the timer expire, or to use the 
        &lt;cancel-commit&gt; operation. The value of this parameter is a token 
        that must be given in the 'persist-id' parameter of &lt;commit&gt; or 
        &lt;cancel-commit&gt; operations in order to confirm or cancel the 
        persistent confirmed commit. The token should be a random string.
    persist_id - str - This parameter is given in order to commit a 
        persistent confirmed commit. The value must be equal to the value 
        given in the 'persist' parameter to the &lt;commit&gt; operation. If it 
        does not match, the operation fails with an 'invalid-value' error.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            confirmed - str - Requests a confirmed commit.
            confirm_timeout - int - The timeout interval for a confirmed commit.
            persist - str - This parameter is used to make a confirmed commit 
                persistent. A persistent confirmed commit is not aborted if the 
                NETCONF session terminates. The only way to abort a persistent 
                confirmed commit is to let the timer expire, or to use the 
                &lt;cancel-commit&gt; operation. The value of this parameter is a token 
                that must be given in the &#39;persist-id&#39; parameter of &lt;commit&gt; or 
                &lt;cancel-commit&gt; operations in order to confirm or cancel the 
                persistent confirmed commit. The token should be a random string.
            persist_id - str - This parameter is given in order to commit a 
                persistent confirmed commit. The value must be equal to the value 
                given in the &#39;persist&#39; parameter to the &lt;commit&gt; operation. If it 
                does not match, the operation fails with an &#39;invalid-value&#39; error.

    ----------------------------
    &#34;&#34;&#34;

    confirmed = kwargs.get(&#39;confirmed&#39;, None)
    confirm_timeout = kwargs.get(&#39;confirm_timeout&#39;, None)
    persist = kwargs.get(&#39;persist&#39;, None)
    persist_id = kwargs.get(&#39;persist_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;confirmed&#34;: confirmed,
        &#34;confirm-timeout&#34;: confirm_timeout,
        &#34;persist&#34;: persist,
        &#34;persist-id&#34;: persist_id
    }

    response = gxutils.send_rpc(manager, &#39;commit&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.copy_config"><code class="name flex">
<span>def <span class="ident">copy_config</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;copy-config&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.create_subscription"><code class="name flex">
<span>def <span class="ident">create_subscription</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    stream - str - An optional parameter that indicates which stream of 
        events is of interest. If not present, then events in the default 
        NETCONF stream will be sent.
    startTime - str - A parameter used to trigger the replay feature and 
        indicates that the replay should start at the time specified. If 
        start time is not present, this is not a replay subscription.
    stopTime - str - An optional parameter used with the optional replay 
        feature to indicate the newest notifications of interest. If stop 
        time is not present, the notifications will continue until the 
        subscription is terminated. Must be used with startTime.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_subscription(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            stream - str - An optional parameter that indicates which stream of 
                events is of interest. If not present, then events in the default 
                NETCONF stream will be sent.
            startTime - str - A parameter used to trigger the replay feature and 
                indicates that the replay should start at the time specified. If 
                start time is not present, this is not a replay subscription.
            stopTime - str - An optional parameter used with the optional replay 
                feature to indicate the newest notifications of interest. If stop 
                time is not present, the notifications will continue until the 
                subscription is terminated. Must be used with startTime.

    ----------------------------
    &#34;&#34;&#34;

    stream = kwargs.get(&#39;stream&#39;, None)
    startTime = kwargs.get(&#39;startTime&#39;, None)
    stopTime = kwargs.get(&#39;stopTime&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;stream&#34;: stream,
        &#34;startTime&#34;: startTime,
        &#34;stopTime&#34;: stopTime
    }

    response = gxutils.send_rpc(manager, &#39;create-subscription&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.create_xcon"><code class="name flex">
<span>def <span class="ident">create_xcon</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    payload_type - str - Indicates a generic, high-level source (from) 
        client payload type of the digital XCON.
    direction - str - Indicates whether the digital XCON is 
        uni-directional (1-WAY) or bi-directional (2-WAY).
    circuit_id_suffix - str - User configured circuit ID suffix.
    label - str - User label.
    source - str - Source end-point of the xcon. Must be an existing 
        facility that can be used as a XCON end-point.
    src_parent_odu - str - Name of the High Order parent ODU where to 
        audst-create this ODU end-point.
    src_time_slots - str - List of time-slots to allocate to the 
        automatically created LO-ODU. Value can be: - omitted/empty - in 
        which case system will audst-allocate time-slots based on the 
        src-instance-id, which becomes mandatory (this is only supported for 
        non ODUflex scenarios.) - starting time-slot - system automatically 
        allocates the rest of the time-slots sequentially from this starting 
        point; will fail if those time-slots are not available - time-slot 
        list - full list of time-slots, using a comma separated list, with 
        'x..y' representing ranges; the total number of time-slots need to 
        match the associated payload-type (e.g. 80 time-slots for 100G 
        payload, 320 time-slots for 400G payload, etc)
    src_instance_id - int - Optional parameter on LO-ODU creation, 
        identifies the ODU within the parent/high-order ODU. If not 
        provided, it is automatically derived. Max value depends on capacity 
        of the HO-ODU and of the odu-type. (ex: for creating an ODU4 in a HO 
        ODUC8, instance can be between 1 and 8) Note: instance-id becomes 
        mandatory if time-slots are not provided.
    destination - str - Destination end-point of the xcon. Must be an 
        existing facility that can be used as a XCON end-point.
    dst_parent_odu - str - Name of the High Order parent ODU where to 
        audst-create this ODU end-point.
    dst_time_slots - str - List of time-slots to allocate to the 
        automatically created LO-ODU. Value can be: - omitted/empty - in 
        which case system will audst-allocate time-slots based on the 
        dst-instance-id, which becomes mandatory (this is only supported for 
        non ODUflex scenarios.) - starting time-slot - system automatically 
        allocates the rest of the time-slots sequentially from this starting 
        point; will fail if those time-slots are not available - time-slot 
        list - full list of time-slots, using a comma separated list, with 
        'x..y' representing ranges; the total number of time-slots need to 
        match the associated payload-type (e.g. 80 time-slots for 100G 
        payload, 320 time-slots for 400G payload, etc)
    dst_instance_id - int - Optional parameter on LO-ODU creation, 
        identifies the ODU within the parent/high-order ODU. If not 
        provided, it is automatically derived. Max value depends on capacity 
        of the HO-ODU and of the odu-type. (ex: for creating an ODU4 in a HO 
        ODUC8, instance can be between 1 and 8) Note: instance-id becomes 
        mandatory if time-slots are not provided.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_xcon(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            payload_type - str - Indicates a generic, high-level source (from) 
                client payload type of the digital XCON.
            direction - str - Indicates whether the digital XCON is 
                uni-directional (1-WAY) or bi-directional (2-WAY).
            circuit_id_suffix - str - User configured circuit ID suffix.
            label - str - User label.
            source - str - Source end-point of the xcon. Must be an existing 
                facility that can be used as a XCON end-point.
            src_parent_odu - str - Name of the High Order parent ODU where to 
                audst-create this ODU end-point.
            src_time_slots - str - List of time-slots to allocate to the 
                automatically created LO-ODU. Value can be: - omitted/empty - in 
                which case system will audst-allocate time-slots based on the 
                src-instance-id, which becomes mandatory (this is only supported for 
                non ODUflex scenarios.) - starting time-slot - system automatically 
                allocates the rest of the time-slots sequentially from this starting 
                point; will fail if those time-slots are not available - time-slot 
                list - full list of time-slots, using a comma separated list, with 
                &#39;x..y&#39; representing ranges; the total number of time-slots need to 
                match the associated payload-type (e.g. 80 time-slots for 100G 
                payload, 320 time-slots for 400G payload, etc)
            src_instance_id - int - Optional parameter on LO-ODU creation, 
                identifies the ODU within the parent/high-order ODU. If not 
                provided, it is automatically derived. Max value depends on capacity 
                of the HO-ODU and of the odu-type. (ex: for creating an ODU4 in a HO 
                ODUC8, instance can be between 1 and 8) Note: instance-id becomes 
                mandatory if time-slots are not provided.
            destination - str - Destination end-point of the xcon. Must be an 
                existing facility that can be used as a XCON end-point.
            dst_parent_odu - str - Name of the High Order parent ODU where to 
                audst-create this ODU end-point.
            dst_time_slots - str - List of time-slots to allocate to the 
                automatically created LO-ODU. Value can be: - omitted/empty - in 
                which case system will audst-allocate time-slots based on the 
                dst-instance-id, which becomes mandatory (this is only supported for 
                non ODUflex scenarios.) - starting time-slot - system automatically 
                allocates the rest of the time-slots sequentially from this starting 
                point; will fail if those time-slots are not available - time-slot 
                list - full list of time-slots, using a comma separated list, with 
                &#39;x..y&#39; representing ranges; the total number of time-slots need to 
                match the associated payload-type (e.g. 80 time-slots for 100G 
                payload, 320 time-slots for 400G payload, etc)
            dst_instance_id - int - Optional parameter on LO-ODU creation, 
                identifies the ODU within the parent/high-order ODU. If not 
                provided, it is automatically derived. Max value depends on capacity 
                of the HO-ODU and of the odu-type. (ex: for creating an ODU4 in a HO 
                ODUC8, instance can be between 1 and 8) Note: instance-id becomes 
                mandatory if time-slots are not provided.

    ----------------------------
    &#34;&#34;&#34;

    payload_type = kwargs.get(&#39;payload_type&#39;, None)
    direction = kwargs.get(&#39;direction&#39;, None)
    circuit_id_suffix = kwargs.get(&#39;circuit_id_suffix&#39;, None)
    label = kwargs.get(&#39;label&#39;, None)
    source = kwargs.get(&#39;source&#39;, None)
    src_parent_odu = kwargs.get(&#39;src_parent_odu&#39;, None)
    src_time_slots = kwargs.get(&#39;src_time_slots&#39;, None)
    src_instance_id = kwargs.get(&#39;src_instance_id&#39;, None)
    destination = kwargs.get(&#39;destination&#39;, None)
    dst_parent_odu = kwargs.get(&#39;dst_parent_odu&#39;, None)
    dst_time_slots = kwargs.get(&#39;dst_time_slots&#39;, None)
    dst_instance_id = kwargs.get(&#39;dst_instance_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;payload-type&#34;: payload_type,
        &#34;direction&#34;: direction,
        &#34;circuit-id-suffix&#34;: circuit_id_suffix,
        &#34;label&#34;: label,
        &#34;source&#34;: source,
        &#34;src-parent-odu&#34;: src_parent_odu,
        &#34;src-time-slots&#34;: src_time_slots,
        &#34;src-instance-id&#34;: src_instance_id,
        &#34;destination&#34;: destination,
        &#34;dst-parent-odu&#34;: dst_parent_odu,
        &#34;dst-time-slots&#34;: dst_time_slots,
        &#34;dst-instance-id&#34;: dst_instance_id
    }

    response = gxutils.send_rpc(manager, &#39;create-xcon&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.csr_gen"><code class="name flex">
<span>def <span class="ident">csr_gen</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    certificate_name - str - Specifies the name of the certificate to be 
        generated. Using existing name implies rotation. NOTE: When 
        importing the signed certificate at a later step, the exact same 
        certificate-name needs to be used.
    signature_hash_algorithm - str - Hash algorithm to be used. Default 
        value depends on the selected key-algorithm.
    metadata_template - str - Selects the possible sources for the CSR 
        metadata, including reusing it from an existing certificate, loading 
        from an openssl cnf file, or using a generic template which defines 
        the metadata defaults. In all cases except for 'from-openssl-cnf', 
        it is possible to override the metadata individual parameters by 
        providing the metadata parameters (subject, SAN, etc) explicitly.
    metadata_from_certificate - unknown - A local-certificate id to be 
        used as metadata source. Metadata details can be overridden 
        separately.
    metadata_from_cnf - str - Multi-line string input of cnf with 
        metadata. Metadata details can be overridden separately.
    subject - str - The certificate subject. The common name (CN) RDN is 
        *mandatory*. Each relative DN must have a prefix slash (/). Example 
        a minimal valid subject (contains CN only): '/CN=Infinera' An 
        example with all supported RDN fields: 
        '/CN=InfineraRoot/C=US/ST=California/L=Sunnyvale/O=InfineraCorporation/OU=InfineraR&amp;D'

    SAN - str - The certificate SAN (Subject Alternate Name) fields. 
        SANs are specified as Type-Value comma separated list. Valid types 
        are 'IP', 'DNS' and 'otherName'. Examples: 
        SAN='IP:127.0.0.1,DNS:localhost' 
        SAN='dns:GX-10-4,otherName:1.3.6.1.4.1.21296.1.2.2.1.2;UTF8:GX-10-4'
    key_usage - str - The Key Usage type(s) for the certificate. Default 
        is derived from the metadata-template parameter.
    extended_key_usage - str - The Extended Key Usage type(s) for the 
        certificate. Default is derived from the metadata-template parameter.
    key_algorithm - str - Specifies the algorithm to be used for a new 
        key pair for this CSR.
    key_from_certificate - unknown - Allows to reuse the key pair from 
        an existing local-certificate.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def csr_gen(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            certificate_name - str - Specifies the name of the certificate to be 
                generated. Using existing name implies rotation. NOTE: When 
                importing the signed certificate at a later step, the exact same 
                certificate-name needs to be used.
            signature_hash_algorithm - str - Hash algorithm to be used. Default 
                value depends on the selected key-algorithm.
            metadata_template - str - Selects the possible sources for the CSR 
                metadata, including reusing it from an existing certificate, loading 
                from an openssl cnf file, or using a generic template which defines 
                the metadata defaults. In all cases except for &#39;from-openssl-cnf&#39;, 
                it is possible to override the metadata individual parameters by 
                providing the metadata parameters (subject, SAN, etc) explicitly.
            metadata_from_certificate - unknown - A local-certificate id to be 
                used as metadata source. Metadata details can be overridden 
                separately.
            metadata_from_cnf - str - Multi-line string input of cnf with 
                metadata. Metadata details can be overridden separately.
            subject - str - The certificate subject. The common name (CN) RDN is 
                *mandatory*. Each relative DN must have a prefix slash (/). Example 
                a minimal valid subject (contains CN only): &#39;/CN=Infinera&#39; An 
                example with all supported RDN fields: 
                &#39;/CN=InfineraRoot/C=US/ST=California/L=Sunnyvale/O=InfineraCorporation/OU=InfineraR&amp;D&#39;
                
            SAN - str - The certificate SAN (Subject Alternate Name) fields. 
                SANs are specified as Type-Value comma separated list. Valid types 
                are &#39;IP&#39;, &#39;DNS&#39; and &#39;otherName&#39;. Examples: 
                SAN=&#39;IP:127.0.0.1,DNS:localhost&#39; 
                SAN=&#39;dns:GX-10-4,otherName:1.3.6.1.4.1.21296.1.2.2.1.2;UTF8:GX-10-4&#39;
            key_usage - str - The Key Usage type(s) for the certificate. Default 
                is derived from the metadata-template parameter.
            extended_key_usage - str - The Extended Key Usage type(s) for the 
                certificate. Default is derived from the metadata-template parameter.
            key_algorithm - str - Specifies the algorithm to be used for a new 
                key pair for this CSR.
            key_from_certificate - unknown - Allows to reuse the key pair from 
                an existing local-certificate.

    ----------------------------
    &#34;&#34;&#34;

    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    signature_hash_algorithm = kwargs.get(&#39;signature_hash_algorithm&#39;, None)
    metadata_template = kwargs.get(&#39;metadata_template&#39;, None)
    metadata_from_certificate = kwargs.get(&#39;metadata_from_certificate&#39;, None)
    metadata_from_cnf = kwargs.get(&#39;metadata_from_cnf&#39;, None)
    subject = kwargs.get(&#39;subject&#39;, None)
    SAN = kwargs.get(&#39;SAN&#39;, None)
    key_usage = kwargs.get(&#39;key_usage&#39;, None)
    extended_key_usage = kwargs.get(&#39;extended_key_usage&#39;, None)
    key_algorithm = kwargs.get(&#39;key_algorithm&#39;, None)
    key_from_certificate = kwargs.get(&#39;key_from_certificate&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;certificate-name&#34;: certificate_name,
        &#34;signature-hash-algorithm&#34;: signature_hash_algorithm,
        &#34;metadata-template&#34;: metadata_template,
        &#34;metadata-from-certificate&#34;: metadata_from_certificate,
        &#34;metadata-from-cnf&#34;: metadata_from_cnf,
        &#34;subject&#34;: subject,
        &#34;SAN&#34;: SAN,
        &#34;key-usage&#34;: key_usage,
        &#34;extended-key-usage&#34;: extended_key_usage,
        &#34;key-algorithm&#34;: key_algorithm,
        &#34;key-from-certificate&#34;: key_from_certificate
    }

    response = gxutils.send_rpc(manager, &#39;csr-gen&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    entity_id - str - Instances to be defaulted.
    attribute - str - Attribute names to be defaulted. If empty, default 
        all entities' attributes.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity_id - str - Instances to be defaulted.
            attribute - str - Attribute names to be defaulted. If empty, default 
                all entities&#39; attributes.

    ----------------------------
    &#34;&#34;&#34;

    entity_id = kwargs.get(&#39;entity_id&#39;, None)
    attribute = kwargs.get(&#39;attribute&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity-id&#34;: entity_id,
        &#34;attribute&#34;: attribute
    }

    response = gxutils.send_rpc(manager, &#39;default&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.delete_config"><code class="name flex">
<span>def <span class="ident">delete_config</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;delete-config&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.delete_isk"><code class="name flex">
<span>def <span class="ident">delete_isk</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    key_name - unknown - Image Signing Key (ISK) name
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_isk(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            key_name - unknown - Image Signing Key (ISK) name

    ----------------------------
    &#34;&#34;&#34;

    key_name = kwargs.get(&#39;key_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;key-name&#34;: key_name
    }

    response = gxutils.send_rpc(manager, &#39;delete-isk&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    candidate - str - The candidate datastore configuration.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            candidate - str - The candidate datastore configuration.

    ----------------------------
    &#34;&#34;&#34;

    candidate = kwargs.get(&#39;candidate&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;candidate&#34;: candidate
    }

    response = gxutils.send_rpc(manager, &#39;diff&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.disable_led"><code class="name flex">
<span>def <span class="ident">disable_led</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    entity - str - Targets a specific entity in the system for having 
        its location led test disabled. Can be a chassis or a card.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_led(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity - str - Targets a specific entity in the system for having 
                its location led test disabled. Can be a chassis or a card.

    ----------------------------
    &#34;&#34;&#34;

    entity = kwargs.get(&#39;entity&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity&#34;: entity
    }

    response = gxutils.send_rpc(manager, &#39;disable-led&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.discard_changes"><code class="name flex">
<span>def <span class="ident">discard_changes</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discard_changes(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;discard-changes&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.display_cert"><code class="name flex">
<span>def <span class="ident">display_cert</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    display_type - str - Defines the requested type of display operation.
    certificate - str - The target certificate to display details or 
        trust-chain.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_cert(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            display_type - str - Defines the requested type of display operation.
            certificate - str - The target certificate to display details or 
                trust-chain.

    ----------------------------
    &#34;&#34;&#34;

    display_type = kwargs.get(&#39;display_type&#39;, None)
    certificate = kwargs.get(&#39;certificate&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;display-type&#34;: display_type,
        &#34;certificate&#34;: certificate
    }

    response = gxutils.send_rpc(manager, &#39;display-cert&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    filetype - str - Predefined filetype available for download
    passphrase - str - To decode encrypted input files.
    white_listed - bool - If true, peer-certificate does not have an 
        associated trust-chain. Else, has an associated trust-chain.
    certificate_name - str - X509v3 local/trusted/peer certificate id.
    intermediate_import - bool - Allow to import any intermediate 
        certificates present in a certificate file bundle. If 
        certificate-name is not provided, it will be auto-generated from the 
        topmost certificate Issuer CN plus a numeric suffix.
    unattended - bool - Auto prepare and auto activate file after a 
        successful download. Only some files support 'activation'; others 
        just ignore this flag.
    async_ - bool - Download asynchronously.
    skip_secure_verification - bool - For HTTPS transfers, skip TLS 
        verification. For SCP/SFTP transfers, skip ssh known host checking. 
        If flag not set, verification is done according with current 
        security-policy.
    sanity_check_override - bool - If true, skips the sanity check 
        override when downloading a database snapshot.
    destination - str - Allows user to provide the destination for the 
        downloaded file, including directory and/or filename. This is only 
        applicable when file-type is 'file', representing a generic file 
        transfer. The parameter can be: - omitted: means file is downloaded 
        to the default directory with the original file-name - a file-name 
        only: uses default directory with the new file-name - a relative 
        path: uses the default directory as starting path, plus relative 
        path - an absolute path: Absolute path for the user accessible 
        directories can be used It is necessary for the user to have write 
        access to the destination path for the download to succeed. Tip: use 
        'show transfer' to see what is the default storage directory. For 
        generic file transfer, no further activity occurs after download, so 
        the 'unattended' flag will be ignored.
    password - str - SFTP/SCP/FTP/HTTP/HTTPS password
    db_passphrase - str - Passphrase used for encrypting and decrypting 
        DB snapshots. For each command associated with DB snapshots (backup, 
        restore, etc), this db-passphrase will be used, except when it is 
        directly provided in each command. Automatic DB snapshots will not 
        be enabled until this parameter is set.
    db_action - str - Specify the expected database operation during 
        activating software image.
    source - str - Source of the download 
        ([sftp|scp|http|https|ftp|file]://[user@]hostname/directorypath/filename)

    file_server - unknown - The preconfigured file-server name.
    path - str - Path (directory and filename) of the remote file.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for download
            passphrase - str - To decode encrypted input files.
            white_listed - bool - If true, peer-certificate does not have an 
                associated trust-chain. Else, has an associated trust-chain.
            certificate_name - str - X509v3 local/trusted/peer certificate id.
            intermediate_import - bool - Allow to import any intermediate 
                certificates present in a certificate file bundle. If 
                certificate-name is not provided, it will be auto-generated from the 
                topmost certificate Issuer CN plus a numeric suffix.
            unattended - bool - Auto prepare and auto activate file after a 
                successful download. Only some files support &#39;activation&#39;; others 
                just ignore this flag.
            async_ - bool - Download asynchronously.
            skip_secure_verification - bool - For HTTPS transfers, skip TLS 
                verification. For SCP/SFTP transfers, skip ssh known host checking. 
                If flag not set, verification is done according with current 
                security-policy.
            sanity_check_override - bool - If true, skips the sanity check 
                override when downloading a database snapshot.
            destination - str - Allows user to provide the destination for the 
                downloaded file, including directory and/or filename. This is only 
                applicable when file-type is &#39;file&#39;, representing a generic file 
                transfer. The parameter can be: - omitted: means file is downloaded 
                to the default directory with the original file-name - a file-name 
                only: uses default directory with the new file-name - a relative 
                path: uses the default directory as starting path, plus relative 
                path - an absolute path: Absolute path for the user accessible 
                directories can be used It is necessary for the user to have write 
                access to the destination path for the download to succeed. Tip: use 
                &#39;show transfer&#39; to see what is the default storage directory. For 
                generic file transfer, no further activity occurs after download, so 
                the &#39;unattended&#39; flag will be ignored.
            password - str - SFTP/SCP/FTP/HTTP/HTTPS password
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.
            db_action - str - Specify the expected database operation during 
                activating software image.
            source - str - Source of the download 
                ([sftp|scp|http|https|ftp|file]://[user@]hostname/directorypath/filename)
                
            file_server - unknown - The preconfigured file-server name.
            path - str - Path (directory and filename) of the remote file.

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    passphrase = kwargs.get(&#39;passphrase&#39;, None)
    white_listed = kwargs.get(&#39;white_listed&#39;, None)
    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    intermediate_import = kwargs.get(&#39;intermediate_import&#39;, None)
    unattended = kwargs.get(&#39;unattended&#39;, None)
    async_ = kwargs.get(&#39;async_&#39;, None)
    skip_secure_verification = kwargs.get(&#39;skip_secure_verification&#39;, None)
    sanity_check_override = kwargs.get(&#39;sanity_check_override&#39;, None)
    destination = kwargs.get(&#39;destination&#39;, None)
    password = kwargs.get(&#39;password&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)
    db_action = kwargs.get(&#39;db_action&#39;, None)
    source = kwargs.get(&#39;source&#39;, None)
    file_server = kwargs.get(&#39;file_server&#39;, None)
    path = kwargs.get(&#39;path&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;passphrase&#34;: passphrase,
        &#34;white-listed&#34;: white_listed,
        &#34;certificate-name&#34;: certificate_name,
        &#34;intermediate-import&#34;: intermediate_import,
        &#34;unattended&#34;: unattended,
        &#34;async&#34;: async_,
        &#34;skip-secure-verification&#34;: skip_secure_verification,
        &#34;sanity-check-override&#34;: sanity_check_override,
        &#34;destination&#34;: destination,
        &#34;password&#34;: password,
        &#34;db-passphrase&#34;: db_passphrase,
        &#34;db-action&#34;: db_action,
        &#34;source&#34;: source,
        &#34;file-server&#34;: file_server,
        &#34;path&#34;: path
    }

    response = gxutils.send_rpc(manager, &#39;download&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.edit_config"><code class="name flex">
<span>def <span class="ident">edit_config</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    default_operation - str - The default operation to use.
    test_option - str - The test option to use.
    error_option - str - The error option to use.
    url - str - URL-based config content.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            default_operation - str - The default operation to use.
            test_option - str - The test option to use.
            error_option - str - The error option to use.
            url - str - URL-based config content.

    ----------------------------
    &#34;&#34;&#34;

    default_operation = kwargs.get(&#39;default_operation&#39;, None)
    test_option = kwargs.get(&#39;test_option&#39;, None)
    error_option = kwargs.get(&#39;error_option&#39;, None)
    url = kwargs.get(&#39;url&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;default-operation&#34;: default_operation,
        &#34;test-option&#34;: test_option,
        &#34;error-option&#34;: error_option,
        &#34;url&#34;: url
    }

    response = gxutils.send_rpc(manager, &#39;edit-config&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.enable_led"><code class="name flex">
<span>def <span class="ident">enable_led</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    entity - str - Targets a specific entity in the system for enabling 
        its location led test. Can be a chassis or a card.
    timeout - int - Specify the timeout, in seconds, before enable-led 
        terminates. 0 means no timeout.
    led_mode - str - Selects the led flash pattern.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_led(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            entity - str - Targets a specific entity in the system for enabling 
                its location led test. Can be a chassis or a card.
            timeout - int - Specify the timeout, in seconds, before enable-led 
                terminates. 0 means no timeout.
            led_mode - str - Selects the led flash pattern.

    ----------------------------
    &#34;&#34;&#34;

    entity = kwargs.get(&#39;entity&#39;, None)
    timeout = kwargs.get(&#39;timeout&#39;, None)
    led_mode = kwargs.get(&#39;led_mode&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;entity&#34;: entity,
        &#34;timeout&#34;: timeout,
        &#34;led-mode&#34;: led_mode
    }

    response = gxutils.send_rpc(manager, &#39;enable-led&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.file_operation"><code class="name flex">
<span>def <span class="ident">file_operation</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    operation - str - File operations to do.
    file_path - str - Current file path.
    new_file_path - str - New file path.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_operation(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            operation - str - File operations to do.
            file_path - str - Current file path.
            new_file_path - str - New file path.

    ----------------------------
    &#34;&#34;&#34;

    operation = kwargs.get(&#39;operation&#39;, None)
    file_path = kwargs.get(&#39;file_path&#39;, None)
    new_file_path = kwargs.get(&#39;new_file_path&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;operation&#34;: operation,
        &#34;file-path&#34;: file_path,
        &#34;new-file-path&#34;: new_file_path
    }

    response = gxutils.send_rpc(manager, &#39;file-operation&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get_conditions"><code class="name flex">
<span>def <span class="ident">get_conditions</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    direction - str - Direction of the condition.
    location - str - Location of the condition.
    resource - str - Existing system resource.
    resource_type - str - Type of resource.
    AID - str - Resource Access Identifier (AID). Identifies an instance 
        within a specific resource type.
    alarm_type - str - Type of alarm, based on an abbreviated code.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_conditions(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            direction - str - Direction of the condition.
            location - str - Location of the condition.
            resource - str - Existing system resource.
            resource_type - str - Type of resource.
            AID - str - Resource Access Identifier (AID). Identifies an instance 
                within a specific resource type.
            alarm_type - str - Type of alarm, based on an abbreviated code.

    ----------------------------
    &#34;&#34;&#34;

    direction = kwargs.get(&#39;direction&#39;, None)
    location = kwargs.get(&#39;location&#39;, None)
    resource = kwargs.get(&#39;resource&#39;, None)
    resource_type = kwargs.get(&#39;resource_type&#39;, None)
    AID = kwargs.get(&#39;AID&#39;, None)
    alarm_type = kwargs.get(&#39;alarm_type&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;direction&#34;: direction,
        &#34;location&#34;: location,
        &#34;resource&#34;: resource,
        &#34;resource-type&#34;: resource_type,
        &#34;AID&#34;: AID,
        &#34;alarm-type&#34;: alarm_type
    }

    response = gxutils.send_rpc(manager, &#39;get-conditions&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;get-config&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get_file"><code class="name flex">
<span>def <span class="ident">get_file</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    path_name - str - If name is a directory, display its list, if name 
        is a file, display its contents. The path can be relative to the 
        /storage directory or absolute.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            path_name - str - If name is a directory, display its list, if name 
                is a file, display its contents. The path can be relative to the 
                /storage directory or absolute.

    ----------------------------
    &#34;&#34;&#34;

    path_name = kwargs.get(&#39;path_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;path-name&#34;: path_name
    }

    response = gxutils.send_rpc(manager, &#39;get-file&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get_log"><code class="name flex">
<span>def <span class="ident">get_log</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    log_file_name - unknown - The log file to read; must match a 
        currently configured log-file.
    start_time - str - Returns log entries starting from this timestamp. 
        If not provided, consider the oldest available logs.
    end_time - str - Returns log entries ending at this timestamp. If 
        not provided, consider all the logs until the most recent timestamp.
    number_of_entries - str - Describes the amount of log entries that 
        are to be returned.
    pattern_match - str - Allows to provide a regex that filters log 
        entries.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_log(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            log_file_name - unknown - The log file to read; must match a 
                currently configured log-file.
            start_time - str - Returns log entries starting from this timestamp. 
                If not provided, consider the oldest available logs.
            end_time - str - Returns log entries ending at this timestamp. If 
                not provided, consider all the logs until the most recent timestamp.
            number_of_entries - str - Describes the amount of log entries that 
                are to be returned.
            pattern_match - str - Allows to provide a regex that filters log 
                entries.

    ----------------------------
    &#34;&#34;&#34;

    log_file_name = kwargs.get(&#39;log_file_name&#39;, None)
    start_time = kwargs.get(&#39;start_time&#39;, None)
    end_time = kwargs.get(&#39;end_time&#39;, None)
    number_of_entries = kwargs.get(&#39;number_of_entries&#39;, None)
    pattern_match = kwargs.get(&#39;pattern_match&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;log-file-name&#34;: log_file_name,
        &#34;start-time&#34;: start_time,
        &#34;end-time&#34;: end_time,
        &#34;number-of-entries&#34;: number_of_entries,
        &#34;pattern-match&#34;: pattern_match
    }

    response = gxutils.send_rpc(manager, &#39;get-log&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get_pm"><code class="name flex">
<span>def <span class="ident">get_pm</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    data_type - str - Type of PM data to retrieve.
    number_of_records - int - Maximum number of records that will be 
        retrieved.
    skip_records - int - Allows user to specify a number of records that 
        will be skipped, so that the total data can be fetched in multiple 
        requests. Example: - system has 2300 PM records available - 1st 
        get-pm with (number-of-records = 1000) and (skip-records = 0); 
        result has 0..1000 records - 2nd get-pm with (number-of-records = 
        1000) and (skip-records = 1000); result has 1001..2000 records - 3nd 
        get-pm with (number-of-records = 1000) and (skip-records = 2000); 
        result has 2001..2300 records
    period - str - Time period for PM data.
    start_time - str - If provided, defines the start timestamp that 
        will be considered to filter the PM results. If not provided, the 
        oldest data timestamp will be considered.
    end_time - str - If provided, defines the end timestamp that will be 
        considered to filter the PM results. If not provided, the most 
        recent data timestamp will be considered.
    start_bin - int - If provided, defines the start bin number that 
        will be considered to filter the PM results. If not provided, the 
        smallest bin number (most recent data) will be considered.
    end_bin - int - If provided, defines the end bin number that will be 
        considered to filter the PM results. If not provided, the largest 
        available bin number (oldest data) will be considered.
    filter_list - list - List of:
        filter-id - int - Identifier for each filter, has no specific meaning.
        resource - str - Existing system resource.
        resource-type - str - Type of resource.
        AID - str - Resource Access Identifier (AID). Identifies an instance 
            within a specific resource type.
        parameter - str - PM parameter identifier (can be a counter or a 
            gauge).
        direction - str - PM parameter direction.
        location - str - PM parameter location.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pm(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            data_type - str - Type of PM data to retrieve.
            number_of_records - int - Maximum number of records that will be 
                retrieved.
            skip_records - int - Allows user to specify a number of records that 
                will be skipped, so that the total data can be fetched in multiple 
                requests. Example: - system has 2300 PM records available - 1st 
                get-pm with (number-of-records = 1000) and (skip-records = 0); 
                result has 0..1000 records - 2nd get-pm with (number-of-records = 
                1000) and (skip-records = 1000); result has 1001..2000 records - 3nd 
                get-pm with (number-of-records = 1000) and (skip-records = 2000); 
                result has 2001..2300 records
            period - str - Time period for PM data.
            start_time - str - If provided, defines the start timestamp that 
                will be considered to filter the PM results. If not provided, the 
                oldest data timestamp will be considered.
            end_time - str - If provided, defines the end timestamp that will be 
                considered to filter the PM results. If not provided, the most 
                recent data timestamp will be considered.
            start_bin - int - If provided, defines the start bin number that 
                will be considered to filter the PM results. If not provided, the 
                smallest bin number (most recent data) will be considered.
            end_bin - int - If provided, defines the end bin number that will be 
                considered to filter the PM results. If not provided, the largest 
                available bin number (oldest data) will be considered.
            filter_list - list - List of:
                filter-id - int - Identifier for each filter, has no specific meaning.
                resource - str - Existing system resource.
                resource-type - str - Type of resource.
                AID - str - Resource Access Identifier (AID). Identifies an instance 
                    within a specific resource type.
                parameter - str - PM parameter identifier (can be a counter or a 
                    gauge).
                direction - str - PM parameter direction.
                location - str - PM parameter location.

    ----------------------------
    &#34;&#34;&#34;

    data_type = kwargs.get(&#39;data_type&#39;, None)
    number_of_records = kwargs.get(&#39;number_of_records&#39;, None)
    skip_records = kwargs.get(&#39;skip_records&#39;, None)
    period = kwargs.get(&#39;period&#39;, None)
    start_time = kwargs.get(&#39;start_time&#39;, None)
    end_time = kwargs.get(&#39;end_time&#39;, None)
    start_bin = kwargs.get(&#39;start_bin&#39;, None)
    end_bin = kwargs.get(&#39;end_bin&#39;, None)
    filter_list = kwargs.get(&#39;filter_list&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;data-type&#34;: data_type,
        &#34;number-of-records&#34;: number_of_records,
        &#34;skip-records&#34;: skip_records,
        &#34;period&#34;: period,
        &#34;start-time&#34;: start_time,
        &#34;end-time&#34;: end_time,
        &#34;start-bin&#34;: start_bin,
        &#34;end-bin&#34;: end_bin,
        &#34;filter&#34;: filter_list
    }

    response = gxutils.send_rpc(manager, &#39;get-pm&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get_schema"><code class="name flex">
<span>def <span class="ident">get_schema</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    identifier - str - Identifier for the schema list entry.
    version - str - Version of the schema requested. If this parameter 
        is not present, and more than one version of the schema exists on 
        the server, a 'data-not-unique' error is returned, as described above.
    format - str - The data modeling language of the schema. If this 
        parameter is not present, and more than one formats of the schema 
        exists on the server, a 'data-not-unique' error is returned, as 
        described above.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_schema(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            identifier - str - Identifier for the schema list entry.
            version - str - Version of the schema requested. If this parameter 
                is not present, and more than one version of the schema exists on 
                the server, a &#39;data-not-unique&#39; error is returned, as described above.
            format - str - The data modeling language of the schema. If this 
                parameter is not present, and more than one formats of the schema 
                exists on the server, a &#39;data-not-unique&#39; error is returned, as 
                described above.

    ----------------------------
    &#34;&#34;&#34;

    identifier = kwargs.get(&#39;identifier&#39;, None)
    version = kwargs.get(&#39;version&#39;, None)
    format = kwargs.get(&#39;format&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;identifier&#34;: identifier,
        &#34;version&#34;: version,
        &#34;format&#34;: format
    }

    response = gxutils.send_rpc(manager, &#39;get-schema&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get_script"><code class="name flex">
<span>def <span class="ident">get_script</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    list_scripts - str - List all existing scripts.
    script_name - str - Get the content of an existing script. The 
        script name is a relative path to the script directory.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_script(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            list_scripts - str - List all existing scripts.
            script_name - str - Get the content of an existing script. The 
                script name is a relative path to the script directory.

    ----------------------------
    &#34;&#34;&#34;

    list_scripts = kwargs.get(&#39;list_scripts&#39;, None)
    script_name = kwargs.get(&#39;script_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;list-scripts&#34;: list_scripts,
        &#34;script-name&#34;: script_name
    }

    response = gxutils.send_rpc(manager, &#39;get-script&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;get&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.import_certificate"><code class="name flex">
<span>def <span class="ident">import_certificate</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    type - str - Certificate types available for import.
    certificate_name - str - X509v3 local/peer/trusted certificate ID.
    certificate_pem - str - Certificate bytes or certificates bundle in 
        PEM format.
    passphrase - str - To decode encrypted input certificates.
    intermediate_import - bool - Allow to import any intermediate 
        certificates present in a PEM string bundle. If certificate-name is 
        not provided, it will be auto-generated from the topmost certificate 
        issuer CN plus a numeric suffix.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_certificate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Certificate types available for import.
            certificate_name - str - X509v3 local/peer/trusted certificate ID.
            certificate_pem - str - Certificate bytes or certificates bundle in 
                PEM format.
            passphrase - str - To decode encrypted input certificates.
            intermediate_import - bool - Allow to import any intermediate 
                certificates present in a PEM string bundle. If certificate-name is 
                not provided, it will be auto-generated from the topmost certificate 
                issuer CN plus a numeric suffix.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    certificate_name = kwargs.get(&#39;certificate_name&#39;, None)
    certificate_pem = kwargs.get(&#39;certificate_pem&#39;, None)
    passphrase = kwargs.get(&#39;passphrase&#39;, None)
    intermediate_import = kwargs.get(&#39;intermediate_import&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;certificate-name&#34;: certificate_name,
        &#34;certificate-pem&#34;: certificate_pem,
        &#34;passphrase&#34;: passphrase,
        &#34;intermediate-import&#34;: intermediate_import
    }

    response = gxutils.send_rpc(manager, &#39;import-certificate&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.install_krp"><code class="name flex">
<span>def <span class="ident">install_krp</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    krp_name - str - Key replacement package name
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install_krp(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            krp_name - str - Key replacement package name

    ----------------------------
    &#34;&#34;&#34;

    krp_name = kwargs.get(&#39;krp_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;krp-name&#34;: krp_name
    }

    response = gxutils.send_rpc(manager, &#39;install-krp&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.kill_session"><code class="name flex">
<span>def <span class="ident">kill_session</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    session_id - unknown - Identifier of the session that will be killed.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill_session(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            session_id - unknown - Identifier of the session that will be killed.

    ----------------------------
    &#34;&#34;&#34;

    session_id = kwargs.get(&#39;session_id&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;session-id&#34;: session_id
    }

    response = gxutils.send_rpc(manager, &#39;kill-session&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.lock"><code class="name flex">
<span>def <span class="ident">lock</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lock(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;lock&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.manual_switchover"><code class="name flex">
<span>def <span class="ident">manual_switchover</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    resource - str - Active controller card to switchover.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manual_switchover(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            resource - str - Active controller card to switchover.

    ----------------------------
    &#34;&#34;&#34;

    resource = kwargs.get(&#39;resource&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;resource&#34;: resource
    }

    response = gxutils.send_rpc(manager, &#39;manual-switchover&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.no_op"><code class="name flex">
<span>def <span class="ident">no_op</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_op(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;no-op&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.password"><code class="name flex">
<span>def <span class="ident">password</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    old_password - str - The current password.
    new_password - str - The new password.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def password(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            old_password - str - The current password.
            new_password - str - The new password.

    ----------------------------
    &#34;&#34;&#34;

    old_password = kwargs.get(&#39;old_password&#39;, None)
    new_password = kwargs.get(&#39;new_password&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;old-password&#34;: old_password,
        &#34;new-password&#34;: new_password
    }

    response = gxutils.send_rpc(manager, &#39;password&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    ping_count - int - Stops after sending 'count' ECHO_REQUEST packets.
    ping_timeout - int - Specify the timeout, in seconds, before ping 
        exits.
    ping_pktsize - int - Specifies the number of bytes to be sent. 
        Default is 56, exclusive of headers.
    ping_dest - str - IP address or FQDN of the destination node.
    ping_interface - unknown - Specify source interface name
    ping_vrf - str - VRF to use. If not provided, defaults to MGMT.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ping_count - int - Stops after sending &#39;count&#39; ECHO_REQUEST packets.
            ping_timeout - int - Specify the timeout, in seconds, before ping 
                exits.
            ping_pktsize - int - Specifies the number of bytes to be sent. 
                Default is 56, exclusive of headers.
            ping_dest - str - IP address or FQDN of the destination node.
            ping_interface - unknown - Specify source interface name
            ping_vrf - str - VRF to use. If not provided, defaults to MGMT.

    ----------------------------
    &#34;&#34;&#34;

    ping_count = kwargs.get(&#39;ping_count&#39;, None)
    ping_timeout = kwargs.get(&#39;ping_timeout&#39;, None)
    ping_pktsize = kwargs.get(&#39;ping_pktsize&#39;, None)
    ping_dest = kwargs.get(&#39;ping_dest&#39;, None)
    ping_interface = kwargs.get(&#39;ping_interface&#39;, None)
    ping_vrf = kwargs.get(&#39;ping_vrf&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ping-count&#34;: ping_count,
        &#34;ping-timeout&#34;: ping_timeout,
        &#34;ping-pktsize&#34;: ping_pktsize,
        &#34;ping-dest&#34;: ping_dest,
        &#34;ping-interface&#34;: ping_interface,
        &#34;ping-vrf&#34;: ping_vrf
    }

    response = gxutils.send_rpc(manager, &#39;ping&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.prepare_upgrade"><code class="name flex">
<span>def <span class="ident">prepare_upgrade</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    option - str - Predefined options available for prepare-upgrade
    manifest - unknown - manifest to be prepared for upgrade
    ignore_precheck_failures - bool - Ignore validation failures.
    unattended - bool - Auto activate software after prepare upgrade.
    db_action - str - Specify the expected database operation during 
        activating software image.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_upgrade(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            option - str - Predefined options available for prepare-upgrade
            manifest - unknown - manifest to be prepared for upgrade
            ignore_precheck_failures - bool - Ignore validation failures.
            unattended - bool - Auto activate software after prepare upgrade.
            db_action - str - Specify the expected database operation during 
                activating software image.

    ----------------------------
    &#34;&#34;&#34;

    option = kwargs.get(&#39;option&#39;, None)
    manifest = kwargs.get(&#39;manifest&#39;, None)
    ignore_precheck_failures = kwargs.get(&#39;ignore_precheck_failures&#39;, None)
    unattended = kwargs.get(&#39;unattended&#39;, None)
    db_action = kwargs.get(&#39;db_action&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;option&#34;: option,
        &#34;manifest&#34;: manifest,
        &#34;ignore-precheck-failures&#34;: ignore_precheck_failures,
        &#34;unattended&#34;: unattended,
        &#34;db-action&#34;: db_action
    }

    response = gxutils.send_rpc(manager, &#39;prepare-upgrade&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.protection_switch"><code class="name flex">
<span>def <span class="ident">protection_switch</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    protection_group - str - The target of the switch command.
    operation_type - str - The type of protection switch command
    switch_target - str - The target of the switch command, which is not 
        needed for release and lockout operation.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protection_switch(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            protection_group - str - The target of the switch command.
            operation_type - str - The type of protection switch command
            switch_target - str - The target of the switch command, which is not 
                needed for release and lockout operation.

    ----------------------------
    &#34;&#34;&#34;

    protection_group = kwargs.get(&#39;protection_group&#39;, None)
    operation_type = kwargs.get(&#39;operation_type&#39;, None)
    switch_target = kwargs.get(&#39;switch_target&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;protection-group&#34;: protection_group,
        &#34;operation-type&#34;: operation_type,
        &#34;switch-target&#34;: switch_target
    }

    response = gxutils.send_rpc(manager, &#39;protection-switch&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.re_auth"><code class="name flex">
<span>def <span class="ident">re_auth</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    ikev2_peer - str - A reference to the IKE peer object (IKE SA).
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def re_auth(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ikev2_peer - str - A reference to the IKE peer object (IKE SA).

    ----------------------------
    &#34;&#34;&#34;

    ikev2_peer = kwargs.get(&#39;ikev2_peer&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ikev2-peer&#34;: ikev2_peer
    }

    response = gxutils.send_rpc(manager, &#39;re-auth&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.re_key"><code class="name flex">
<span>def <span class="ident">re_key</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    ipsec_security_association - str - Points to IPsec SPD entry object 
        (Child SA).
    ikev2_peer - str - A reference to the IKE peer object (IKE SA).
    secure_entity - str - Points to secure entity object (Child SA).
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def re_key(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            ipsec_security_association - str - Points to IPsec SPD entry object 
                (Child SA).
            ikev2_peer - str - A reference to the IKE peer object (IKE SA).
            secure_entity - str - Points to secure entity object (Child SA).

    ----------------------------
    &#34;&#34;&#34;

    ipsec_security_association = kwargs.get(&#39;ipsec_security_association&#39;, None)
    ikev2_peer = kwargs.get(&#39;ikev2_peer&#39;, None)
    secure_entity = kwargs.get(&#39;secure_entity&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;ipsec-security-association&#34;: ipsec_security_association,
        &#34;ikev2-peer&#34;: ikev2_peer,
        &#34;secure-entity&#34;: secure_entity
    }

    response = gxutils.send_rpc(manager, &#39;re-key&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.restart"><code class="name flex">
<span>def <span class="ident">restart</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    resource - str - Resource to restart. If not provided, by default 
        restarts the node controller.
    type - str - Restart type
    sub_component - str - Allows to target a card sub-component to 
        restart.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restart(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            resource - str - Resource to restart. If not provided, by default 
                restarts the node controller.
            type - str - Restart type
            sub_component - str - Allows to target a card sub-component to 
                restart.

    ----------------------------
    &#34;&#34;&#34;

    resource = kwargs.get(&#39;resource&#39;, None)
    type = kwargs.get(&#39;type&#39;, None)
    sub_component = kwargs.get(&#39;sub_component&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;resource&#34;: resource,
        &#34;type&#34;: type,
        &#34;sub-component&#34;: sub_component
    }

    response = gxutils.send_rpc(manager, &#39;restart&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.run_script"><code class="name flex">
<span>def <span class="ident">run_script</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    script_name - str - Script absolute or relative path from the script 
        directory.
    arguments - str - Optional arguments to the script.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_script(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            script_name - str - Script absolute or relative path from the script 
                directory.
            arguments - str - Optional arguments to the script.

    ----------------------------
    &#34;&#34;&#34;

    script_name = kwargs.get(&#39;script_name&#39;, None)
    arguments = kwargs.get(&#39;arguments&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;script-name&#34;: script_name,
        &#34;arguments&#34;: arguments
    }

    response = gxutils.send_rpc(manager, &#39;run-script&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.run_task"><code class="name flex">
<span>def <span class="ident">run_task</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    task_name - unknown - The task name to be executed.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_task(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            task_name - unknown - The task name to be executed.

    ----------------------------
    &#34;&#34;&#34;

    task_name = kwargs.get(&#39;task_name&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;task-name&#34;: task_name
    }

    response = gxutils.send_rpc(manager, &#39;run-task&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.set_alarm_state"><code class="name flex">
<span>def <span class="ident">set_alarm_state</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    state - str - Alarm state.
    acknowledge_text - str - Optional text that will be stored in the 
        alarm.
    all_alarms - str - Acknowledge all currently raised alarms.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_alarm_state(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            state - str - Alarm state.
            acknowledge_text - str - Optional text that will be stored in the 
                alarm.
            all_alarms - str - Acknowledge all currently raised alarms.

    ----------------------------
    &#34;&#34;&#34;

    state = kwargs.get(&#39;state&#39;, None)
    acknowledge_text = kwargs.get(&#39;acknowledge_text&#39;, None)
    all_alarms = kwargs.get(&#39;all_alarms&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;state&#34;: state,
        &#34;acknowledge-text&#34;: acknowledge_text,
        &#34;all-alarms&#34;: all_alarms
    }

    response = gxutils.send_rpc(manager, &#39;set-alarm-state&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.set_time"><code class="name flex">
<span>def <span class="ident">set_time</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    new_time - str - Time to set in the system
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            new_time - str - Time to set in the system

    ----------------------------
    &#34;&#34;&#34;

    new_time = kwargs.get(&#39;new_time&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;new-time&#34;: new_time
    }

    response = gxutils.send_rpc(manager, &#39;set-time&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    trigger - str - The alarm event trigger to simulate.
    holder_AID - str - AID of the equipment holder (slot or port) where 
        the equipment will be simulated.
    type - str - The type of the equipment to be simulated.
    subtype - str - The subtype of the equipment to be simulated.
    alarmed_entity - str - The entity affected by the alarm; if ommitted 
        when clearing alarms, all simulated alarms are cleared.
    alarm_type - str - The alarm type to be simulated; if ommitted when 
        clearing alarms, all simulated alarms are cleared.
    alarm_direction - str - The direction of the simulated alarm. If 
        ommitted, system selects direction automatically.
    alarm_location - str - The location of the simulated alarm. If 
        ommitted, system selects location automatically.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            trigger - str - The alarm event trigger to simulate.
            holder_AID - str - AID of the equipment holder (slot or port) where 
                the equipment will be simulated.
            type - str - The type of the equipment to be simulated.
            subtype - str - The subtype of the equipment to be simulated.
            alarmed_entity - str - The entity affected by the alarm; if ommitted 
                when clearing alarms, all simulated alarms are cleared.
            alarm_type - str - The alarm type to be simulated; if ommitted when 
                clearing alarms, all simulated alarms are cleared.
            alarm_direction - str - The direction of the simulated alarm. If 
                ommitted, system selects direction automatically.
            alarm_location - str - The location of the simulated alarm. If 
                ommitted, system selects location automatically.

    ----------------------------
    &#34;&#34;&#34;

    trigger = kwargs.get(&#39;trigger&#39;, None)
    holder_AID = kwargs.get(&#39;holder_AID&#39;, None)
    type = kwargs.get(&#39;type&#39;, None)
    subtype = kwargs.get(&#39;subtype&#39;, None)
    alarmed_entity = kwargs.get(&#39;alarmed_entity&#39;, None)
    alarm_type = kwargs.get(&#39;alarm_type&#39;, None)
    alarm_direction = kwargs.get(&#39;alarm_direction&#39;, None)
    alarm_location = kwargs.get(&#39;alarm_location&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;trigger&#34;: trigger,
        &#34;holder-AID&#34;: holder_AID,
        &#34;type&#34;: type,
        &#34;subtype&#34;: subtype,
        &#34;alarmed-entity&#34;: alarmed_entity,
        &#34;alarm-type&#34;: alarm_type,
        &#34;alarm-direction&#34;: alarm_direction,
        &#34;alarm-location&#34;: alarm_location
    }

    response = gxutils.send_rpc(manager, &#39;simulate&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.ssh_keygen"><code class="name flex">
<span>def <span class="ident">ssh_keygen</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    key_length - str - Strength of the key used for regenerating the 
        private-public key pair
    key_type - str - Type of key to generate
    key_label - str - Label associated with the key. If no value 
        provided, label will be the value of ne-id
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ssh_keygen(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            key_length - str - Strength of the key used for regenerating the 
                private-public key pair
            key_type - str - Type of key to generate
            key_label - str - Label associated with the key. If no value 
                provided, label will be the value of ne-id

    ----------------------------
    &#34;&#34;&#34;

    key_length = kwargs.get(&#39;key_length&#39;, None)
    key_type = kwargs.get(&#39;key_type&#39;, None)
    key_label = kwargs.get(&#39;key_label&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;key-length&#34;: key_length,
        &#34;key-type&#34;: key_type,
        &#34;key-label&#34;: key_label
    }

    response = gxutils.send_rpc(manager, &#39;ssh-keygen&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.take_snapshot"><code class="name flex">
<span>def <span class="ident">take_snapshot</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    type - str - Location where the snapshot will be stored.
    db_instance - str - Target db-instance name which will hold the DB 
        snapshot.
    description - str - Optional description for this DB snapshot.
    db_passphrase - str - Passphrase used for encrypting and decrypting 
        DB snapshots. For each command associated with DB snapshots (backup, 
        restore, etc), this db-passphrase will be used, except when it is 
        directly provided in each command. Automatic DB snapshots will not 
        be enabled until this parameter is set.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take_snapshot(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            type - str - Location where the snapshot will be stored.
            db_instance - str - Target db-instance name which will hold the DB 
                snapshot.
            description - str - Optional description for this DB snapshot.
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.

    ----------------------------
    &#34;&#34;&#34;

    type = kwargs.get(&#39;type&#39;, None)
    db_instance = kwargs.get(&#39;db_instance&#39;, None)
    description = kwargs.get(&#39;description&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;type&#34;: type,
        &#34;db-instance&#34;: db_instance,
        &#34;description&#34;: description,
        &#34;db-passphrase&#34;: db_passphrase
    }

    response = gxutils.send_rpc(manager, &#39;take-snapshot&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.traceroute"><code class="name flex">
<span>def <span class="ident">traceroute</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    tr_hopcnt - int - Specifies the maximum number of hops (max 
        time-to-live value) traceroute will probe. The default is 10.
    tr_timeout - int - Specify the timeout, in seconds, before trace 
        route exits.
    tr_dest - str - IPv4/v6 address or FQDN of the destination node.
    tr_pktsize - int - Specifies the total size of the probing packet 
        (default 60 bytes for IPv4).
    tr_interface - unknown - Specify source interface name
    tr_vrf - str - VRF to use. If not provided, defaults to MGMT.
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traceroute(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            tr_hopcnt - int - Specifies the maximum number of hops (max 
                time-to-live value) traceroute will probe. The default is 10.
            tr_timeout - int - Specify the timeout, in seconds, before trace 
                route exits.
            tr_dest - str - IPv4/v6 address or FQDN of the destination node.
            tr_pktsize - int - Specifies the total size of the probing packet 
                (default 60 bytes for IPv4).
            tr_interface - unknown - Specify source interface name
            tr_vrf - str - VRF to use. If not provided, defaults to MGMT.

    ----------------------------
    &#34;&#34;&#34;

    tr_hopcnt = kwargs.get(&#39;tr_hopcnt&#39;, None)
    tr_timeout = kwargs.get(&#39;tr_timeout&#39;, None)
    tr_dest = kwargs.get(&#39;tr_dest&#39;, None)
    tr_pktsize = kwargs.get(&#39;tr_pktsize&#39;, None)
    tr_interface = kwargs.get(&#39;tr_interface&#39;, None)
    tr_vrf = kwargs.get(&#39;tr_vrf&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;tr-hopcnt&#34;: tr_hopcnt,
        &#34;tr-timeout&#34;: tr_timeout,
        &#34;tr-dest&#34;: tr_dest,
        &#34;tr-pktsize&#34;: tr_pktsize,
        &#34;tr-interface&#34;: tr_interface,
        &#34;tr-vrf&#34;: tr_vrf
    }

    response = gxutils.send_rpc(manager, &#39;traceroute&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.unlock"><code class="name flex">
<span>def <span class="ident">unlock</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlock(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;unlock&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
    filetype - str - Predefined filetype available for upload
    source - str - Allows user to provide the source for the file to be 
        uploaded, including directory and/or filename. This is only 
        applicable when file-type is 'file', representing a generic file 
        transfer. Can be a path relative to the default user directory, or 
        an absolute path - as long as user has access to the target file.
    async_ - bool - Uploads asynchronously.
    skip_secure_verification - bool - For HTTPS transfers, skip TLS 
        verification. For SCP/SFTP transfers, skip ssh known host checking. 
        If flag not set, verification is done according with current 
        security-policy.
    debug_entity - str - Targets a specific entity in the system for 
        having its Logs to be collected. Can be a chassis or a card
    password - str - SFTP/SCP/FTP/HTTP/HTTPS password
    start_time - str - Start time from where the logs should be 
        collected. It can be a timestamp or a time interval from the actual 
        time (now). If empty all log history is selected
    db_instance - str - Selected DB instance
    optional_content - str - List of files to be included for debug-log 
        upload.
    log_file_list - unknown - List of log files to be uploaded. If empty 
        all available logs are selected.
    period - str - Time period for PM data.
    db_passphrase - str - Passphrase used for encrypting and decrypting 
        DB snapshots. For each command associated with DB snapshots (backup, 
        restore, etc), this db-passphrase will be used, except when it is 
        directly provided in each command. Automatic DB snapshots will not 
        be enabled until this parameter is set.
    destination - str - Destination of the upload 
        ([sftp|scp|ftp|https|http|file]://[user@]hostname/directorypath/filename)

    file_server - unknown - The preconfigured file-server name.
    path - str - Path (directory and filename) to be used in the remote 
        file-server. If not provided, the file-server initial-path is used, 
        with system defined filename. If the path targets a directory (e.g. 
        /path/ ), the filename is dynamically generated. Otherwise, the user 
        defined filename may use some placeholders %t and %m (representing 
        timestamp and ne-name respectively).
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:
            filetype - str - Predefined filetype available for upload
            source - str - Allows user to provide the source for the file to be 
                uploaded, including directory and/or filename. This is only 
                applicable when file-type is &#39;file&#39;, representing a generic file 
                transfer. Can be a path relative to the default user directory, or 
                an absolute path - as long as user has access to the target file.
            async_ - bool - Uploads asynchronously.
            skip_secure_verification - bool - For HTTPS transfers, skip TLS 
                verification. For SCP/SFTP transfers, skip ssh known host checking. 
                If flag not set, verification is done according with current 
                security-policy.
            debug_entity - str - Targets a specific entity in the system for 
                having its Logs to be collected. Can be a chassis or a card
            password - str - SFTP/SCP/FTP/HTTP/HTTPS password
            start_time - str - Start time from where the logs should be 
                collected. It can be a timestamp or a time interval from the actual 
                time (now). If empty all log history is selected
            db_instance - str - Selected DB instance
            optional_content - str - List of files to be included for debug-log 
                upload.
            log_file_list - unknown - List of log files to be uploaded. If empty 
                all available logs are selected.
            period - str - Time period for PM data.
            db_passphrase - str - Passphrase used for encrypting and decrypting 
                DB snapshots. For each command associated with DB snapshots (backup, 
                restore, etc), this db-passphrase will be used, except when it is 
                directly provided in each command. Automatic DB snapshots will not 
                be enabled until this parameter is set.
            destination - str - Destination of the upload 
                ([sftp|scp|ftp|https|http|file]://[user@]hostname/directorypath/filename)
                
            file_server - unknown - The preconfigured file-server name.
            path - str - Path (directory and filename) to be used in the remote 
                file-server. If not provided, the file-server initial-path is used, 
                with system defined filename. If the path targets a directory (e.g. 
                /path/ ), the filename is dynamically generated. Otherwise, the user 
                defined filename may use some placeholders %t and %m (representing 
                timestamp and ne-name respectively).

    ----------------------------
    &#34;&#34;&#34;

    filetype = kwargs.get(&#39;filetype&#39;, None)
    source = kwargs.get(&#39;source&#39;, None)
    async_ = kwargs.get(&#39;async_&#39;, None)
    skip_secure_verification = kwargs.get(&#39;skip_secure_verification&#39;, None)
    debug_entity = kwargs.get(&#39;debug_entity&#39;, None)
    password = kwargs.get(&#39;password&#39;, None)
    start_time = kwargs.get(&#39;start_time&#39;, None)
    db_instance = kwargs.get(&#39;db_instance&#39;, None)
    optional_content = kwargs.get(&#39;optional_content&#39;, None)
    log_file_list = kwargs.get(&#39;log_file_list&#39;, None)
    period = kwargs.get(&#39;period&#39;, None)
    db_passphrase = kwargs.get(&#39;db_passphrase&#39;, None)
    destination = kwargs.get(&#39;destination&#39;, None)
    file_server = kwargs.get(&#39;file_server&#39;, None)
    path = kwargs.get(&#39;path&#39;, None)

    manager = kwargs.get(&#39;manager&#39;)

    request = {
        &#34;filetype&#34;: filetype,
        &#34;source&#34;: source,
        &#34;async&#34;: async_,
        &#34;skip-secure-verification&#34;: skip_secure_verification,
        &#34;debug-entity&#34;: debug_entity,
        &#34;password&#34;: password,
        &#34;start-time&#34;: start_time,
        &#34;db-instance&#34;: db_instance,
        &#34;optional-content&#34;: optional_content,
        &#34;log-file-list&#34;: log_file_list,
        &#34;period&#34;: period,
        &#34;db-passphrase&#34;: db_passphrase,
        &#34;destination&#34;: destination,
        &#34;file-server&#34;: file_server,
        &#34;path&#34;: path
    }

    response = gxutils.send_rpc(manager, &#39;upload&#39;, request)
    return response</code></pre>
</details>
</dd>
<dt id="gx_rpcs.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><hr>
<pre><code>Inputs:
</code></pre>
<hr></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(handle, **kwargs):
    &#34;&#34;&#34;
    ----------------------------
        Inputs:

    ----------------------------
    &#34;&#34;&#34;


    manager = kwargs.get(&#39;manager&#39;)

    request = {}

    response = gxutils.send_rpc(manager, &#39;validate&#39;, request)
    return response</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gx_rpcs.activate_file" href="#gx_rpcs.activate_file">activate_file</a></code></li>
<li><code><a title="gx_rpcs.activate_fw" href="#gx_rpcs.activate_fw">activate_fw</a></code></li>
<li><code><a title="gx_rpcs.appctl" href="#gx_rpcs.appctl">appctl</a></code></li>
<li><code><a title="gx_rpcs.apply_template" href="#gx_rpcs.apply_template">apply_template</a></code></li>
<li><code><a title="gx_rpcs.call_home" href="#gx_rpcs.call_home">call_home</a></code></li>
<li><code><a title="gx_rpcs.cancel_commit" href="#gx_rpcs.cancel_commit">cancel_commit</a></code></li>
<li><code><a title="gx_rpcs.cancel_upgrade" href="#gx_rpcs.cancel_upgrade">cancel_upgrade</a></code></li>
<li><code><a title="gx_rpcs.cert_gen" href="#gx_rpcs.cert_gen">cert_gen</a></code></li>
<li><code><a title="gx_rpcs.change_ztp_mode" href="#gx_rpcs.change_ztp_mode">change_ztp_mode</a></code></li>
<li><code><a title="gx_rpcs.clear_alarm" href="#gx_rpcs.clear_alarm">clear_alarm</a></code></li>
<li><code><a title="gx_rpcs.clear_app" href="#gx_rpcs.clear_app">clear_app</a></code></li>
<li><code><a title="gx_rpcs.clear_certificate" href="#gx_rpcs.clear_certificate">clear_certificate</a></code></li>
<li><code><a title="gx_rpcs.clear_crl" href="#gx_rpcs.clear_crl">clear_crl</a></code></li>
<li><code><a title="gx_rpcs.clear_database" href="#gx_rpcs.clear_database">clear_database</a></code></li>
<li><code><a title="gx_rpcs.clear_diagnostics" href="#gx_rpcs.clear_diagnostics">clear_diagnostics</a></code></li>
<li><code><a title="gx_rpcs.clear_file" href="#gx_rpcs.clear_file">clear_file</a></code></li>
<li><code><a title="gx_rpcs.clear_log" href="#gx_rpcs.clear_log">clear_log</a></code></li>
<li><code><a title="gx_rpcs.clear_ospf_instance" href="#gx_rpcs.clear_ospf_instance">clear_ospf_instance</a></code></li>
<li><code><a title="gx_rpcs.clear_pm" href="#gx_rpcs.clear_pm">clear_pm</a></code></li>
<li><code><a title="gx_rpcs.clear_recover_mode" href="#gx_rpcs.clear_recover_mode">clear_recover_mode</a></code></li>
<li><code><a title="gx_rpcs.clear_system" href="#gx_rpcs.clear_system">clear_system</a></code></li>
<li><code><a title="gx_rpcs.clear_topology" href="#gx_rpcs.clear_topology">clear_topology</a></code></li>
<li><code><a title="gx_rpcs.cli_command" href="#gx_rpcs.cli_command">cli_command</a></code></li>
<li><code><a title="gx_rpcs.close_session" href="#gx_rpcs.close_session">close_session</a></code></li>
<li><code><a title="gx_rpcs.commit" href="#gx_rpcs.commit">commit</a></code></li>
<li><code><a title="gx_rpcs.copy_config" href="#gx_rpcs.copy_config">copy_config</a></code></li>
<li><code><a title="gx_rpcs.create_subscription" href="#gx_rpcs.create_subscription">create_subscription</a></code></li>
<li><code><a title="gx_rpcs.create_xcon" href="#gx_rpcs.create_xcon">create_xcon</a></code></li>
<li><code><a title="gx_rpcs.csr_gen" href="#gx_rpcs.csr_gen">csr_gen</a></code></li>
<li><code><a title="gx_rpcs.default" href="#gx_rpcs.default">default</a></code></li>
<li><code><a title="gx_rpcs.delete_config" href="#gx_rpcs.delete_config">delete_config</a></code></li>
<li><code><a title="gx_rpcs.delete_isk" href="#gx_rpcs.delete_isk">delete_isk</a></code></li>
<li><code><a title="gx_rpcs.diff" href="#gx_rpcs.diff">diff</a></code></li>
<li><code><a title="gx_rpcs.disable_led" href="#gx_rpcs.disable_led">disable_led</a></code></li>
<li><code><a title="gx_rpcs.discard_changes" href="#gx_rpcs.discard_changes">discard_changes</a></code></li>
<li><code><a title="gx_rpcs.display_cert" href="#gx_rpcs.display_cert">display_cert</a></code></li>
<li><code><a title="gx_rpcs.download" href="#gx_rpcs.download">download</a></code></li>
<li><code><a title="gx_rpcs.edit_config" href="#gx_rpcs.edit_config">edit_config</a></code></li>
<li><code><a title="gx_rpcs.enable_led" href="#gx_rpcs.enable_led">enable_led</a></code></li>
<li><code><a title="gx_rpcs.file_operation" href="#gx_rpcs.file_operation">file_operation</a></code></li>
<li><code><a title="gx_rpcs.get_conditions" href="#gx_rpcs.get_conditions">get_conditions</a></code></li>
<li><code><a title="gx_rpcs.get_config" href="#gx_rpcs.get_config">get_config</a></code></li>
<li><code><a title="gx_rpcs.get_file" href="#gx_rpcs.get_file">get_file</a></code></li>
<li><code><a title="gx_rpcs.get_log" href="#gx_rpcs.get_log">get_log</a></code></li>
<li><code><a title="gx_rpcs.get_pm" href="#gx_rpcs.get_pm">get_pm</a></code></li>
<li><code><a title="gx_rpcs.get_schema" href="#gx_rpcs.get_schema">get_schema</a></code></li>
<li><code><a title="gx_rpcs.get_script" href="#gx_rpcs.get_script">get_script</a></code></li>
<li><code><a title="gx_rpcs.get" href="#gx_rpcs.get">get</a></code></li>
<li><code><a title="gx_rpcs.import_certificate" href="#gx_rpcs.import_certificate">import_certificate</a></code></li>
<li><code><a title="gx_rpcs.install_krp" href="#gx_rpcs.install_krp">install_krp</a></code></li>
<li><code><a title="gx_rpcs.kill_session" href="#gx_rpcs.kill_session">kill_session</a></code></li>
<li><code><a title="gx_rpcs.lock" href="#gx_rpcs.lock">lock</a></code></li>
<li><code><a title="gx_rpcs.manual_switchover" href="#gx_rpcs.manual_switchover">manual_switchover</a></code></li>
<li><code><a title="gx_rpcs.no_op" href="#gx_rpcs.no_op">no_op</a></code></li>
<li><code><a title="gx_rpcs.password" href="#gx_rpcs.password">password</a></code></li>
<li><code><a title="gx_rpcs.ping" href="#gx_rpcs.ping">ping</a></code></li>
<li><code><a title="gx_rpcs.prepare_upgrade" href="#gx_rpcs.prepare_upgrade">prepare_upgrade</a></code></li>
<li><code><a title="gx_rpcs.protection_switch" href="#gx_rpcs.protection_switch">protection_switch</a></code></li>
<li><code><a title="gx_rpcs.re_auth" href="#gx_rpcs.re_auth">re_auth</a></code></li>
<li><code><a title="gx_rpcs.re_key" href="#gx_rpcs.re_key">re_key</a></code></li>
<li><code><a title="gx_rpcs.restart" href="#gx_rpcs.restart">restart</a></code></li>
<li><code><a title="gx_rpcs.run_script" href="#gx_rpcs.run_script">run_script</a></code></li>
<li><code><a title="gx_rpcs.run_task" href="#gx_rpcs.run_task">run_task</a></code></li>
<li><code><a title="gx_rpcs.set_alarm_state" href="#gx_rpcs.set_alarm_state">set_alarm_state</a></code></li>
<li><code><a title="gx_rpcs.set_time" href="#gx_rpcs.set_time">set_time</a></code></li>
<li><code><a title="gx_rpcs.simulate" href="#gx_rpcs.simulate">simulate</a></code></li>
<li><code><a title="gx_rpcs.ssh_keygen" href="#gx_rpcs.ssh_keygen">ssh_keygen</a></code></li>
<li><code><a title="gx_rpcs.take_snapshot" href="#gx_rpcs.take_snapshot">take_snapshot</a></code></li>
<li><code><a title="gx_rpcs.traceroute" href="#gx_rpcs.traceroute">traceroute</a></code></li>
<li><code><a title="gx_rpcs.unlock" href="#gx_rpcs.unlock">unlock</a></code></li>
<li><code><a title="gx_rpcs.upload" href="#gx_rpcs.upload">upload</a></code></li>
<li><code><a title="gx_rpcs.validate" href="#gx_rpcs.validate">validate</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>