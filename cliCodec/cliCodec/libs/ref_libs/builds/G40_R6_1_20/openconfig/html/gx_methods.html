<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gx_methods API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gx_methods</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gx_methods.create_card"><code class="name flex">
<span>def <span class="ident">create_card</span></span>(<span>handle, component_name, chassis_name, slot_name, required_type, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str
:param chassis_name: Chassis where this card is located.
:type chassis_name: str
:param slot_name: Slot where this card is located.
:type slot_name: str
:param required_type: Chassis/card type.
:type required_type: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:required_subtype: str - The subtype of the Card/TOM
:alarm_report_control: str - Controls the reporting of alarms for this particular object.
:label: str - User label.
:alias_name: str - User defined alias for this entity. Must be an alphanumeric string with dash or underscore.
:power_admin_state: str - Enable or disable power to the linecard
</code></pre>
<p><strong>Example</strong>
::
gxctrl.create_card('g40', component_name='card-1-6', chassis_name='1', slot_name='6', required_type='CHM6', yang_type='openconfig')</p></div>
</dd>
<dt id="gx_methods.get_card"><code class="name flex">
<span>def <span class="ident">get_card</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p>
<p><strong>Example</strong>
::
card_data = gxctrl.get_card('g40', 'card-1-6')</p></div>
</dd>
<dt id="gx_methods.delete_card"><code class="name flex">
<span>def <span class="ident">delete_card</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.create_tom"><code class="name flex">
<span>def <span class="ident">create_tom</span></span>(<span>handle, component_name, phy_mode, required_subtype, form_factor_preconf, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str
:param phy_mode: Configured Phy Mode.
:type phy_mode: str
:param required_subtype: The subtype of the Card/TOM
:type required_subtype: str
:param form_factor_preconf: Indicates the type of optical transceiver used on this port.
If the client port is built into the device and not pluggable, then non-pluggable is the corresponding state. If a device port supports multiple form factors (e.g. QSFP28 and QSFP+, then the value of the transceiver installed shall be reported. If no transceiver is present, then the value of the highest rate form factor shall be reported (QSFP28, for example).
The form factor is included in configuration data to allow pre-configuring a device with the expected type of transceiver ahead of deployment.
The corresponding state leaf should reflect the actual transceiver type plugged into the system.
:type form_factor_preconf: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:alarm_report_control: str - Controls the reporting of alarms for this particular object.
:label: str - User label.
:alias_name: str - User defined alias for this entity. Must be an alphanumeric string with dash or underscore.
:serdes_name: str - Name of the advanced parameter.
:value: str - Value of the advanced parameter.
:enabled: bool - Turns power on / off to the transceiver -- provides a means to power on/off the transceiver (in the case of SFP, SFP+, QSFP,...) or enable high-power mode (in the case of CFP, CFP2, CFP4) and is optionally supported (device can choose to always enable).  True = power on / high power, False = powered off
:fec_mode: str - The FEC mode indicates the mode of operation for the transceiver's FEC. This defines typical operational modes and does not aim to specify more granular FEC capabilities.
</code></pre>
<p><strong>Example</strong>
::
gxctrl.create_tom('g40', component_name='tom-1-6-T1', phy_mode='100G', required_subtype='TOM-100GMR-Q-LR4', form_factor_preconf='QSFP28', yang_type='openconfig')</p></div>
</dd>
<dt id="gx_methods.get_tom"><code class="name flex">
<span>def <span class="ident">get_tom</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.delete_tom"><code class="name flex">
<span>def <span class="ident">delete_tom</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.create_super_channel"><code class="name flex">
<span>def <span class="ident">create_super_channel</span></span>(<span>handle, component_name, carriers, operational_mode, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str
:param carriers: A list of carriers that are bound to this superchannel.
Possible values can be any card/resources/supported-carriers.
:type carriers: str
:param operational_mode: Vendor-specific mode identifier &ndash; sets the operational mode for the channel.
The specified operational mode must exist in the list of supported operational modes supplied by the device
:type operational_mode: int</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:admin_state: str - The administrative state of the managed object.
:alarm_report_control: str - Controls the reporting of alarms for this particular object.
:label: str - User label.
</code></pre>
<p><strong>Example</strong>
::
gxctrl.create_super_channel('g40', component_name='super-channel-SCH11', carriers='1-6-L1-1', operational_mode=488, yang_type='openconfig')</p></div>
</dd>
<dt id="gx_methods.get_super_channel"><code class="name flex">
<span>def <span class="ident">get_super_channel</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.delete_super_channel"><code class="name flex">
<span>def <span class="ident">delete_super_channel</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.update_super_channel_group"><code class="name flex">
<span>def <span class="ident">update_super_channel_group</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:component_name: str - References the component name
:auto_in_service_enabled: bool - Auto-in-service switch for this facility.
:valid_signal_time: int - Configurable time that represents a detection of a valid signal. Used for auto-in-service mechanism.
:line_system_mode: str - Indicates the specific mode of power control configured    on the L1 transponder, and specifically, on this particular SCG port within    the L1 transponder. The attribute indicates the L1 &lt;-&gt; L0 local power controls    to adjust the Tx power from the L1 transponder towards the L0 line-system    card (such as a WSS or Mux or Amplifier).
:openwave_contention_check: bool - Enables DNA assisted contention control mechanism in openwave mode.
:alarm_report_control: str - Controls the reporting of alarms for this particular object.
:label: str - User label.
:enabled: bool - Turns power on / off to the transceiver -- provides a means to power on/off the transceiver (in the case of SFP, SFP+, QSFP,...) or enable high-power mode (in the case of CFP, CFP2, CFP4) and is optionally supported (device can choose to always enable).  True = power on / high power, False = powered off
</code></pre></div>
</dd>
<dt id="gx_methods.get_super_channel_group"><code class="name flex">
<span>def <span class="ident">get_super_channel_group</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.update_optical_carrier_line"><code class="name flex">
<span>def <span class="ident">update_optical_carrier_line</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:frequency_offset: int - A super set range for line and client side carrier, specific sub-range is depend on application. Frequency-offset can be used for bright tuning    of the wavelengths.    Once set, the frequency will slowly change (over 1-10s) without affecting service.
:pre_fec_q_sig_deg_threshold: decimal64 - The threshold based on which the PRE-FEC-Q-SIGNAL-DEGRADE alarm is raised.    0 implies threshold crossing alarming disabled.    Specific sub-range is per carrier use-case.
:pre_fec_q_sig_deg_hysteresis: decimal64 - Hysteresis to account for raising of the PRE-FEC-Q-SIGNAL-DEGRADE alarm.
:tx_cd: decimal64 - The configured transmit pre-compensation chromatic dispersion.
:post_fec_q_sig_deg_threshold: decimal64 - The threshold based on which the POST-FEC-Q-SIGNAL-DEGRADE alarm is raised.
:post_fec_q_sig_deg_hysteresis: decimal64 - Hysteresis to account for raising of the POST-FEC-Q-SIGNAL-DEGRADE alarm.
:enable_advanced_parameters: bool - Controls enabling/disabling of configuring advanced parameters for this object.
:admin_state: str - The administrative state of the managed object.
:alarm_report_control: str - Controls the reporting of alarms for this particular object.
:label: str - User label.
:advanced_parameter_name: str - Name of the advanced parameter.
:value: str - Value of the advanced parameter.
:frequency: int - Frequency of the optical channel, expressed in MHz
:target_output_power: str - Target output optical power level of the optical channel, expressed in increments of 0.01 dBm (decibel-milliwats)
:state_of_polarization_sampling: union - Enables per-optical channel collection of SoP data. If SoP collection is enabled, this attribute indicates the sampling interval (i.e., sampling of the SoP data done by the DSP.)
</code></pre></div>
</dd>
<dt id="gx_methods.get_optical_carrier_line"><code class="name flex">
<span>def <span class="ident">get_optical_carrier_line</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.update_optical_carrier_client"><code class="name flex">
<span>def <span class="ident">update_optical_carrier_client</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:frequency_offset: int - A super set range for line and client side carrier, specific sub-range is depend on application. Frequency-offset can be used for bright tuning    of the wavelengths.    Once set, the frequency will slowly change (over 1-10s) without affecting service.
:pre_fec_q_sig_deg_threshold: decimal64 - The threshold based on which the PRE-FEC-Q-SIGNAL-DEGRADE alarm is raised.    0 implies threshold crossing alarming disabled.    Specific sub-range is per carrier use-case.
:pre_fec_q_sig_deg_hysteresis: decimal64 - Hysteresis to account for raising of the PRE-FEC-Q-SIGNAL-DEGRADE alarm.
:admin_state: str - The administrative state of the managed object.
:alarm_report_control: str - Controls the reporting of alarms for this particular object.
:label: str - User label.
:frequency: int - Frequency of the optical channel, expressed in MHz
:target_output_power: str - Target output optical power level of the optical channel, expressed in increments of 0.01 dBm (decibel-milliwats)
:state_of_polarization_sampling: union - Enables per-optical channel collection of SoP data. If SoP collection is enabled, this attribute indicates the sampling interval (i.e., sampling of the SoP data done by the DSP.)
</code></pre></div>
</dd>
<dt id="gx_methods.get_optical_carrier_client"><code class="name flex">
<span>def <span class="ident">get_optical_carrier_client</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.create_lo_odu"><code class="name flex">
<span>def <span class="ident">create_lo_odu</span></span>(<span>handle, channel_index, trib_protocol, parent_odu, tributary_slot_index, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param channel_index: Reference to the index of the logical channel
:type channel_index: int
:param trib_protocol: Protocol framing of the tributary signal. If this LogicalChannel is directly connected to a Client-Port or Optical-Channel, this is the protocol of the associated port. If the LogicalChannel is connected to other LogicalChannels, the TributaryProtocol of the LogicalChannels will define a specific mapping/demapping or multiplexing/demultiplexing function.
Not all protocols are valid, depending on the value of trib-rate-class.
The expectation is that the NMS will validate that a correct combination of rate class and protocol are specfied.
Basic combinations are:
rate class: 1G protocols: 1GE
rate class: 2.5G protocols: OC48, STM16
rate class: 10G protocols:
10GE LAN, 10GE WAN, OC192, STM64, OTU2, OTU2e,
OTU1e, ODU2, ODU2e, ODU1e
rate class: 40G protocols:
40GE, OC768, STM256, OTU3, ODU3
rate class: 100G protocols:
100GE, 100G MLG, OTU4, OTUCn, ODU4
:type trib_protocol: str
:param parent_odu: For low order ODUs, points to the the parent HO-ODU name.
:type parent_odu: unknown
:param tributary_slot_index: Indicates the first tributary slot index allocated to the client signal or logical channel in the assignment. Valid only when the assignment is to an OTN logical channel.
:type tributary_slot_index: int</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:channel_description: str - Description of the logical channel
:admin_state: str - Sets the admin state of the logical channel
:logical_channel_type: str - The type / stage of the logical element determines the configuration and operational state parameters (PMs) available for the logical element
:allocation: str - Allocation of the logical client channel to the tributary or sub-channel, expressed in Gbps. Please note that if the assignment is to an OTN logical channel, the allocation must be an integer multiplication to tributary-slot-granularity of the OTN logical channel.
</code></pre>
<p><strong>Example</strong>
::
gxctrl.create_lo_odu('g40', channel_index=42, trib_protocol='PROT_ODU4i', parent_odu='odu-1-6-L1-1', tributary_slot_index=81, yang_type='openconfig')</p></div>
</dd>
<dt id="gx_methods.get_lo_odu"><code class="name flex">
<span>def <span class="ident">get_lo_odu</span></span>(<span>handle, channel_index, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param channel_index: Reference to the index of the logical channel
:type channel_index: int</p></div>
</dd>
<dt id="gx_methods.delete_lo_odu"><code class="name flex">
<span>def <span class="ident">delete_lo_odu</span></span>(<span>handle, channel_index, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param channel_index: Reference to the index of the logical channel
:type channel_index: int</p></div>
</dd>
<dt id="gx_methods.create_xcon"><code class="name flex">
<span>def <span class="ident">create_xcon</span></span>(<span>handle, source, destination_index, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param source: The source end-point between which the XCON needs to be created.
:type source: int
:param destination_index: Index of the destination channel between which the XCON needs to be created.
:type destination_index: unknown</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:allocation: str - Allocation of the logical client channel to the tributary or sub-channel, expressed in Gbps. Please note that if the assignment is to an OTN logical channel, the allocation must be an integer multiplication to tributary-slot-granularity of the OTN logical channel.
</code></pre>
<p><strong>Example</strong>
::
gxctrl.create_xcon('g40', source='ethernet-1-6-T1', destination_index=42, yang_type='openconfig')</p></div>
</dd>
<dt id="gx_methods.get_xcon"><code class="name flex">
<span>def <span class="ident">get_xcon</span></span>(<span>handle, source, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param source: The source end-point between which the XCON needs to be created.
:type source: int</p></div>
</dd>
<dt id="gx_methods.delete_xcon"><code class="name flex">
<span>def <span class="ident">delete_xcon</span></span>(<span>handle, source, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param source: The source end-point between which the XCON needs to be created.
:type source: int</p></div>
</dd>
<dt id="gx_methods.update_chassis"><code class="name flex">
<span>def <span class="ident">update_chassis</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str
:param required_type: Chassis/card type.
:type required_type: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:admin_state: str - The administrative state of the managed object.
:alarm_report_control: str - Controls the reporting of alarms for this particular object.
:label: str - User label.
:alias_name: str - User defined alias for this entity. Must be an alphanumeric string with dash or underscore.
:chassis_location: str - User defined location
:rack_name: str - User defined rack name (withing the location)
:position_in_rack: int - Position of the chassis within the rack.
:expected_pem_type: str - Defines what is the expected type of PEMs that this chassis will have. It is not possible to configure each PEM slot individually, as all PEMs need to be of the same type.
:expected_fan_type: str - Defines what is the expected type of FANs that this chassis will have. It is not possible to configure each FAN slot individually, this needs to be done at the chassis level.
:pem_under_voltage_threshold: decimal64 - Under voltage threshold on PEM input feed.
:pem_over_voltage_threshold: decimal64 - Over voltage threshold on PEM input feed.
:configured_ambient_temperature: int - Configured ambient temperature for the chassis, used to compute the FRU's power consumption.
:configured_max_power_draw: decimal64 - User configured limit of power usable by this chassis.    If current-estimated-power-draw used in this chassis goes above the configured-max-power-draw,    the alarm PWRDRAW is raised. 10000W represents a 'very high' power draw that is beyond any    chassis possibilities, so having this value means this feature is disabled, and the alarm is never raised.
:no_switchover: str - If enabled, the standby controller will be locked out from taking over the active card. This means no manual or autonomous switchovers will happen.
:power_redundancy: str - Configuration of the PEM redundancy mode.
:expected_serial_number: str - Inform the NC the serial number of a sub-chassis. For the main-chassis, the value is auto-filled with its own serial number.
</code></pre></div>
</dd>
<dt id="gx_methods.get_chassis"><code class="name flex">
<span>def <span class="ident">get_chassis</span></span>(<span>handle, component_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param component_name: References the component name
:type component_name: str</p></div>
</dd>
<dt id="gx_methods.update_system"><code class="name flex">
<span>def <span class="ident">update_system</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:motd_banner: str - The console message displayed after a user logs into the system.  They system may append additional standard information such as the current system date and time, uptime, last login timestamp, etc.
:hostname: str - The hostname of the device -- should be a single domain label, without the domain.
:login_banner: str - The console login message displayed before the login prompt, i.e., before a user logs into the system.
</code></pre></div>
</dd>
<dt id="gx_methods.get_system"><code class="name flex">
<span>def <span class="ident">get_system</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p></div>
</dd>
<dt id="gx_methods.update_clock"><code class="name flex">
<span>def <span class="ident">update_clock</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:timezone_name: str - The TZ database name to use for the system, such as 'Europe/Stockholm'.
</code></pre></div>
</dd>
<dt id="gx_methods.get_clock"><code class="name flex">
<span>def <span class="ident">get_clock</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p></div>
</dd>
<dt id="gx_methods.create_aaa_radius"><code class="name flex">
<span>def <span class="ident">create_aaa_radius</span></span>(<span>handle, server_address, server_priority, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: Reference to the configured address of the AAA server
:type server_address: str
:param server_priority: Reference to the configured address of the AAA server
:type server_priority: uint32</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:timeout: int - Reference to the configured address of the AAA server
:auth_port: int - Port number for authentication requests
:acct_port: int - Port number for accounting requests
:secret_key: str - The unencrypted shared key used between the authentication server and the device.
:source_address: str - Source IP address to use in messages to the RADIUS server
:retransmit_attempts: int - Number of times the system may resend a request to the RADIUS server when it is unresponsive
</code></pre>
<p><strong>Example</strong>
::
gxctrl.create_aaa_radius('g40', '1.1.1.1', 2, timeout=5, auth_port=1812, acct_port=1813, source_address='auto')</p></div>
</dd>
<dt id="gx_methods.get_aaa_radius"><code class="name flex">
<span>def <span class="ident">get_aaa_radius</span></span>(<span>handle, server_group_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_group_name: Reference to configured name of the server group
:type server_group_name: str</p></div>
</dd>
<dt id="gx_methods.delete_aaa_radius"><code class="name flex">
<span>def <span class="ident">delete_aaa_radius</span></span>(<span>handle, server_group_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_group_name: Reference to configured name of the server group
:type server_group_name: str</p></div>
</dd>
<dt id="gx_methods.create_aaa_tacacs"><code class="name flex">
<span>def <span class="ident">create_aaa_tacacs</span></span>(<span>handle, server_address, server_priority, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: Reference to the configured address of the AAA server
:type server_address: str
:param server_priority: This is used to sort the servers in the order of precedence
:type server_priority: uint32</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:timeout: int - Reference to the configured address of the AAA server
:port: int - Port number for authentication requests
</code></pre>
<p><strong>Example</strong>
::
gxctrl.create_aaa_tacacs('g40', '2.2.2.2', 3, timeout=5, port=1815)</p></div>
</dd>
<dt id="gx_methods.get_aaa_tacacs"><code class="name flex">
<span>def <span class="ident">get_aaa_tacacs</span></span>(<span>handle, server_group_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_group_name: Reference to configured name of the server group
:type server_group_name: str</p></div>
</dd>
<dt id="gx_methods.delete_aaa_tacacs"><code class="name flex">
<span>def <span class="ident">delete_aaa_tacacs</span></span>(<span>handle, server_group_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_group_name: Reference to configured name of the server group
:type server_group_name: str</p></div>
</dd>
<dt id="gx_methods.update_ntp"><code class="name flex">
<span>def <span class="ident">update_ntp</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:enabled: bool - Enables the NTP protocol and indicates that the system should attempt to synchronize the system clock with an NTP server from the servers defined in the 'ntp/server' list.
:enable_ntp_auth: bool - Enable or disable NTP authentication -- when enabled, the system will only use packets containing a trusted authentication key to synchronize the time.
</code></pre></div>
</dd>
<dt id="gx_methods.get_ntp"><code class="name flex">
<span>def <span class="ident">get_ntp</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p></div>
</dd>
<dt id="gx_methods.create_ntp_key"><code class="name flex">
<span>def <span class="ident">create_ntp_key</span></span>(<span>handle, ntp_key_key_id, key_type, key_value, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param ntp_key_key_id: Reference to auth key-id list key
:type ntp_key_key_id: int
:param key_type: Encryption type used for the NTP authentication key
:type key_type: str
:param key_value: NTP authentication key value
:type key_value: str</p>
<p><strong>Optional Parameters</strong>:</p>
<p><strong>Example</strong>
::
gxctrl.create_ntp_key('g40', 123, 'NTP_AUTH_MD5', 'myntpkeyval')</p></div>
</dd>
<dt id="gx_methods.get_ntp_key"><code class="name flex">
<span>def <span class="ident">get_ntp_key</span></span>(<span>handle, ntp_key_key_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param ntp_key_key_id: Reference to auth key-id list key
:type ntp_key_key_id: int</p></div>
</dd>
<dt id="gx_methods.delete_ntp_key"><code class="name flex">
<span>def <span class="ident">delete_ntp_key</span></span>(<span>handle, ntp_key_key_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param ntp_key_key_id: Reference to auth key-id list key
:type ntp_key_key_id: int</p></div>
</dd>
<dt id="gx_methods.create_ntp_server"><code class="name flex">
<span>def <span class="ident">create_ntp_server</span></span>(<span>handle, server_address, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: References the configured address or hostname of the NTP server.
:type server_address: str</p>
<p><strong>Optional Parameters</strong>:</p>
<p><strong>Example</strong>
::
gxctrl.create_ntp_server('g40', '4.4.4.4')</p></div>
</dd>
<dt id="gx_methods.get_ntp_server"><code class="name flex">
<span>def <span class="ident">get_ntp_server</span></span>(<span>handle, server_address, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: References the configured address or hostname of the NTP server.
:type server_address: str</p></div>
</dd>
<dt id="gx_methods.delete_ntp_server"><code class="name flex">
<span>def <span class="ident">delete_ntp_server</span></span>(<span>handle, server_address, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: References the configured address or hostname of the NTP server.
:type server_address: str</p></div>
</dd>
<dt id="gx_methods.update_grpc_server"><code class="name flex">
<span>def <span class="ident">update_grpc_server</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:enable: bool - Enables the gRPC server. The gRPC server is enabled by default
:port: int - TCP port on which the gRPC server should listen
:certificate_id: str - The certificate ID to be used for authentication
</code></pre>
<p><strong>Example</strong>
::
gxctrl.update_grpc_server('g40', enable=True, port=1014)</p></div>
</dd>
<dt id="gx_methods.get_grpc_server"><code class="name flex">
<span>def <span class="ident">get_grpc_server</span></span>(<span>handle, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p></div>
</dd>
<dt id="gx_methods.create_dns"><code class="name flex">
<span>def <span class="ident">create_dns</span></span>(<span>handle, server_address, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: References the configured address of the DNS server
:type server_address: str</p>
<p><strong>Optional Parameters</strong>:</p></div>
</dd>
<dt id="gx_methods.update_dns"><code class="name flex">
<span>def <span class="ident">update_dns</span></span>(<span>handle, server_address, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: References the configured address of the DNS server
:type server_address: str</p>
<p><strong>Optional Parameters</strong>:</p></div>
</dd>
<dt id="gx_methods.get_dns"><code class="name flex">
<span>def <span class="ident">get_dns</span></span>(<span>handle, server_address, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: References the configured address of the DNS server
:type server_address: str</p></div>
</dd>
<dt id="gx_methods.delete_dns"><code class="name flex">
<span>def <span class="ident">delete_dns</span></span>(<span>handle, server_address, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param server_address: References the configured address of the DNS server
:type server_address: str</p></div>
</dd>
<dt id="gx_methods.update_lldp"><code class="name flex">
<span>def <span class="ident">update_lldp</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:lldp_enabled: bool - System level state of the LLDP protocol.
:hello_timer: int - 
:suppress_tlv_advertisement: str - 
:system_name: str - 
:system_description: str - 
:chassis_id: int - 
:chassis_id_type: int - 
:interface_name: str - 
:interface_enabled: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.get_lldp"><code class="name flex">
<span>def <span class="ident">get_lldp</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name:
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.create_static_route"><code class="name flex">
<span>def <span class="ident">create_static_route</span></span>(<span>handle, static_prefix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:vrf: str - VRF associated with this static route.
:advertised: bool - When set to YES, the static route is advertised in the routing protocol. For OSPF, the static route will be advertised as an AS external route, if OSPF is configured as an ASBR.
:label: str - User label.
:next_hop_index: str - 
:next_hop: str - 
:metric: str - 
:recurse: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.update_static_route"><code class="name flex">
<span>def <span class="ident">update_static_route</span></span>(<span>handle, static_prefix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:vrf: str - VRF associated with this static route.
:advertised: bool - When set to YES, the static route is advertised in the routing protocol. For OSPF, the static route will be advertised as an AS external route, if OSPF is configured as an ASBR.
:label: str - User label.
:next_hop_index: str - 
:next_hop: str - 
:metric: str - 
:recurse: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.get_static_route"><code class="name flex">
<span>def <span class="ident">get_static_route</span></span>(<span>handle, static_prefix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str</p></div>
</dd>
<dt id="gx_methods.delete_static_route"><code class="name flex">
<span>def <span class="ident">delete_static_route</span></span>(<span>handle, static_prefix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str</p></div>
</dd>
<dt id="gx_methods.create_static_route_dcn"><code class="name flex">
<span>def <span class="ident">create_static_route_dcn</span></span>(<span>handle, static_prefix, interface, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str
:param interface:
:type interface: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:vrf: str - VRF associated with this static route.
:advertised: bool - When set to YES, the static route is advertised in the routing protocol. For OSPF, the static route will be advertised as an AS external route, if OSPF is configured as an ASBR.
:label: str - User label.
:next_hop_index: str - 
:next_hop: str - 
:metric: str - 
:recurse: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.update_static_route_dcn"><code class="name flex">
<span>def <span class="ident">update_static_route_dcn</span></span>(<span>handle, static_prefix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str
:param interface:
:type interface: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:vrf: str - VRF associated with this static route.
:advertised: bool - When set to YES, the static route is advertised in the routing protocol. For OSPF, the static route will be advertised as an AS external route, if OSPF is configured as an ASBR.
:label: str - User label.
:next_hop_index: str - 
:next_hop: str - 
:metric: str - 
:recurse: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.get_static_route_dcn"><code class="name flex">
<span>def <span class="ident">get_static_route_dcn</span></span>(<span>handle, static_prefix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str</p></div>
</dd>
<dt id="gx_methods.delete_static_route_dcn"><code class="name flex">
<span>def <span class="ident">delete_static_route_dcn</span></span>(<span>handle, static_prefix, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param static_prefix:
:type static_prefix: str</p></div>
</dd>
<dt id="gx_methods.create_lo_mgmt"><code class="name flex">
<span>def <span class="ident">create_lo_mgmt</span></span>(<span>handle, type, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param type: The type of the interface.
When an interface entry is created, a server MAY initialize the type leaf with a valid value, e.g., if it is possible to derive the type from the name of the interface.
If a client tries to set the type of an interface to a value that can never be used by the system, e.g., if the type is not supported or if the type does not match the name of the interface, the server MUST reject the request. A NETCONF server MUST reply with an rpc-error with the error-tag 'invalid-value' in this case.
:type type: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:subinterface_index: int - The index number of the subinterface -- used to address the logical interface
:description: str - A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports ':startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy-config from 'running' to 'startup'.  If the device does not support ':startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore.
:subinterface_enabled: bool - This leaf contains the configured, desired state of the interface.  Systems that implement the IF-MIB use the value of this leaf in the 'running' datastore to set IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry has been initialized, as described in RFC 2863.  Changes in this leaf in the 'running' datastore are reflected in ifAdminStatus, but if ifAdminStatus is changed over SNMP, this leaf is not affected.
:address_ip: str - 
:address_prefix_length: int - 
:ipv4_enabled: bool - 
:ipv4_dhcp_client: bool - 
:ipv6_enabled: bool - 
:ipv6_dhcp_client: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.update_lo_mgmt"><code class="name flex">
<span>def <span class="ident">update_lo_mgmt</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param type: The type of the interface.
When an interface entry is created, a server MAY initialize the type leaf with a valid value, e.g., if it is possible to derive the type from the name of the interface.
If a client tries to set the type of an interface to a value that can never be used by the system, e.g., if the type is not supported or if the type does not match the name of the interface, the server MUST reject the request. A NETCONF server MUST reply with an rpc-error with the error-tag 'invalid-value' in this case.
:type type: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:subinterface_index: int - The index number of the subinterface -- used to address the logical interface
:description: str - A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports ':startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy-config from 'running' to 'startup'.  If the device does not support ':startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore.
:subinterface_enabled: bool - This leaf contains the configured, desired state of the interface.  Systems that implement the IF-MIB use the value of this leaf in the 'running' datastore to set IF-MIB.ifAdminStatus to 'up' or 'down' after an ifEntry has been initialized, as described in RFC 2863.  Changes in this leaf in the 'running' datastore are reflected in ifAdminStatus, but if ifAdminStatus is changed over SNMP, this leaf is not affected.
:address_ip: str - 
:address_prefix_length: int - 
:ipv4_enabled: bool - 
:ipv4_dhcp_client: bool - 
:ipv6_enabled: bool - 
:ipv6_dhcp_client: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.get_lo_mgmt"><code class="name flex">
<span>def <span class="ident">get_lo_mgmt</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.delete_lo_mgmt"><code class="name flex">
<span>def <span class="ident">delete_lo_mgmt</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.update_interface"><code class="name flex">
<span>def <span class="ident">update_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param type: The type of the interface.
When an interface entry is created, a server MAY initialize the type leaf with a valid value, e.g., if it is possible to derive the type from the name of the interface.
If a client tries to set the type of an interface to a value that can never be used by the system, e.g., if the type is not supported or if the type does not match the name of the interface, the server MUST reject the request. A NETCONF server MUST reply with an rpc-error with the error-tag 'invalid-value' in this case.
:type type: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:interface_name: str - References the name of the interface
:mtu: int - Set the max transmission unit size in octets for the physical interface.  If this is not set, the mtu is set to the operational default -- e.g., 1514 bytes on an Ethernet interface.
:subinterface_index: int - The index number of the subinterface -- used to address the logical interface
:description: str - A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports ':startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy-config from 'running' to 'startup'.  If the device does not support ':startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore.
</code></pre></div>
</dd>
<dt id="gx_methods.get_interface"><code class="name flex">
<span>def <span class="ident">get_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.update_ethernet_interface"><code class="name flex">
<span>def <span class="ident">update_ethernet_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param type: The type of the interface.
When an interface entry is created, a server MAY initialize the type leaf with a valid value, e.g., if it is possible to derive the type from the name of the interface.
If a client tries to set the type of an interface to a value that can never be used by the system, e.g., if the type is not supported or if the type does not match the name of the interface, the server MUST reject the request. A NETCONF server MUST reply with an rpc-error with the error-tag 'invalid-value' in this case.
:type type: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:interface_name: str - References the name of the interface
</code></pre></div>
</dd>
<dt id="gx_methods.get_ethernet_interface"><code class="name flex">
<span>def <span class="ident">get_ethernet_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.update_aux_interface"><code class="name flex">
<span>def <span class="ident">update_aux_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:mtu: int - Set the max transmission unit size in octets for the physical interface.  If this is not set, the mtu is set to the operational default -- e.g., 1514 bytes on an Ethernet interface.
:subinterface_index: int - The index number of the subinterface -- used to address the logical interface
:description: str - A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports ':startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy-config from 'running' to 'startup'.  If the device does not support ':startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore.
:ipv4_enabled: bool - 
:ipv4_dhcp_client: bool - 
:address_ip: str - 
:address_prefix_length: int - 
:ipv6_enabled: bool - 
:ipv6_dhcp_client: bool - 
:auto_negotiate: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.get_aux_interface"><code class="name flex">
<span>def <span class="ident">get_aux_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.update_dcn_interface"><code class="name flex">
<span>def <span class="ident">update_dcn_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:mtu: int - Set the max transmission unit size in octets for the physical interface.  If this is not set, the mtu is set to the operational default -- e.g., 1514 bytes on an Ethernet interface.
:subinterface_index: int - The index number of the subinterface -- used to address the logical interface
:description: str - A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports ':startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy-config from 'running' to 'startup'.  If the device does not support ':startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore.
:ipv4_enabled: bool - 
:ipv4_dhcp_client: bool - 
:address_ip: str - 
:address_prefix_length: int - 
:ipv6_enabled: bool - 
:ipv6_dhcp_client: bool - 
:auto_negotiate: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.get_dcn_interface"><code class="name flex">
<span>def <span class="ident">get_dcn_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.update_craft_interface"><code class="name flex">
<span>def <span class="ident">update_craft_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:mtu: int - Set the max transmission unit size in octets for the physical interface.  If this is not set, the mtu is set to the operational default -- e.g., 1514 bytes on an Ethernet interface.
:subinterface_index: int - The index number of the subinterface -- used to address the logical interface
:description: str - A textual description of the interface.  A server implementation MAY map this leaf to the ifAlias MIB object.  Such an implementation needs to use some mechanism to handle the differences in size and characters allowed between this leaf and ifAlias.  The definition of such a mechanism is outside the scope of this document.  Since ifAlias is defined to be stored in non-volatile storage, the MIB implementation MUST map ifAlias to the value of 'description' in the persistently stored datastore.  Specifically, if the device supports ':startup', when ifAlias is read the device MUST return the value of 'description' in the 'startup' datastore, and when it is written, it MUST be written to the 'running' and 'startup' datastores.  Note that it is up to the implementation to  decide whether to modify this single leaf in 'startup' or perform an implicit copy-config from 'running' to 'startup'.  If the device does not support ':startup', ifAlias MUST be mapped to the 'description' leaf in the 'running' datastore.
:ipv4_enabled: bool - 
:ipv4_dhcp_client: bool - 
:address_ip: str - 
:address_prefix_length: int - 
:ipv6_enabled: bool - 
:ipv6_dhcp_client: bool - 
:auto_negotiate: bool -
</code></pre></div>
</dd>
<dt id="gx_methods.get_craft_interface"><code class="name flex">
<span>def <span class="ident">get_craft_interface</span></span>(<span>handle, interface_name, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param interface_name: References the name of the interface
:type interface_name: str</p></div>
</dd>
<dt id="gx_methods.create_dial_out_server"><code class="name flex">
<span>def <span class="ident">create_dial_out_server</span></span>(<span>handle, destination_group_group_id, destination_destination_address, destination_destination_port, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param destination_group_group_id: Unique identifier for the destination group
:type destination_group_group_id: str
:param destination_destination_address: IP address of the telemetry stream destination
:type destination_destination_address: str
:param destination_destination_port: Protocol (udp or tcp) port number for the telemetry stream destination
:type destination_destination_port: int</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:protocol: str - Dial-out-server session type.
:retry_policy: str - Retry policy after a timeout.
:retry: int - Number of retries before giving up.
:timeout: int - Wait time until timeout.
:auto_connect: bool - If true, automatically tries to connect to this dial-out-server. Note that a server with auto-connect false can still be connected manually via the call-home RPC.
:alarm_report_control: str - Controls the reporting of alarms for this particular object.
</code></pre></div>
</dd>
<dt id="gx_methods.get_dial_out_server"><code class="name flex">
<span>def <span class="ident">get_dial_out_server</span></span>(<span>handle, destination_group_group_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param destination_group_group_id: Unique identifier for the destination group
:type destination_group_group_id: str</p></div>
</dd>
<dt id="gx_methods.delete_dial_out_server"><code class="name flex">
<span>def <span class="ident">delete_dial_out_server</span></span>(<span>handle, destination_group_group_id, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param destination_group_group_id: Unique identifier for the destination group
:type destination_group_group_id: str</p></div>
</dd>
<dt id="gx_methods.create_user"><code class="name flex">
<span>def <span class="ident">create_user</span></span>(<span>handle, user_username, password, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param user_username: References the configured username for the user
:type user_username: str
:param password: The user password, supplied as cleartext.
The system must hash the value and only store the hashed value.
:type password: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:password_hashed: str - The user password, supplied as a hashed value using the notation described in the definition of the crypt-password-type.
:ssh_key: str - SSH public key for the user (RSA or DSA)
:role: str - Role assigned to the user.  The role may be supplied as a string or a role defined by the SYSTEM_DEFINED_ROLES identity.
</code></pre></div>
</dd>
<dt id="gx_methods.update_user"><code class="name flex">
<span>def <span class="ident">update_user</span></span>(<span>handle, user_username, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param user_username: References the configured username for the user
:type user_username: str
:param password: The user password, supplied as cleartext.
The system must hash the value and only store the hashed value.
:type password: str</p>
<p><strong>Optional Parameters</strong>:</p>
<pre><code>:password_hashed: str - The user password, supplied as a hashed value using the notation described in the definition of the crypt-password-type.
:ssh_key: str - SSH public key for the user (RSA or DSA)
:role: str - Role assigned to the user.  The role may be supplied as a string or a role defined by the SYSTEM_DEFINED_ROLES identity.
</code></pre></div>
</dd>
<dt id="gx_methods.get_user"><code class="name flex">
<span>def <span class="ident">get_user</span></span>(<span>handle, user_username, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param user_username: References the configured username for the user
:type user_username: str</p></div>
</dd>
<dt id="gx_methods.delete_user"><code class="name flex">
<span>def <span class="ident">delete_user</span></span>(<span>handle, user_username, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param handle: gxctrl connection handle
:type handle: str
:param user_username: References the configured username for the user
:type user_username: str</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gx_methods.create_card" href="#gx_methods.create_card">create_card</a></code></li>
<li><code><a title="gx_methods.get_card" href="#gx_methods.get_card">get_card</a></code></li>
<li><code><a title="gx_methods.delete_card" href="#gx_methods.delete_card">delete_card</a></code></li>
<li><code><a title="gx_methods.create_tom" href="#gx_methods.create_tom">create_tom</a></code></li>
<li><code><a title="gx_methods.get_tom" href="#gx_methods.get_tom">get_tom</a></code></li>
<li><code><a title="gx_methods.delete_tom" href="#gx_methods.delete_tom">delete_tom</a></code></li>
<li><code><a title="gx_methods.create_super_channel" href="#gx_methods.create_super_channel">create_super_channel</a></code></li>
<li><code><a title="gx_methods.get_super_channel" href="#gx_methods.get_super_channel">get_super_channel</a></code></li>
<li><code><a title="gx_methods.delete_super_channel" href="#gx_methods.delete_super_channel">delete_super_channel</a></code></li>
<li><code><a title="gx_methods.update_super_channel_group" href="#gx_methods.update_super_channel_group">update_super_channel_group</a></code></li>
<li><code><a title="gx_methods.get_super_channel_group" href="#gx_methods.get_super_channel_group">get_super_channel_group</a></code></li>
<li><code><a title="gx_methods.update_optical_carrier_line" href="#gx_methods.update_optical_carrier_line">update_optical_carrier_line</a></code></li>
<li><code><a title="gx_methods.get_optical_carrier_line" href="#gx_methods.get_optical_carrier_line">get_optical_carrier_line</a></code></li>
<li><code><a title="gx_methods.update_optical_carrier_client" href="#gx_methods.update_optical_carrier_client">update_optical_carrier_client</a></code></li>
<li><code><a title="gx_methods.get_optical_carrier_client" href="#gx_methods.get_optical_carrier_client">get_optical_carrier_client</a></code></li>
<li><code><a title="gx_methods.create_lo_odu" href="#gx_methods.create_lo_odu">create_lo_odu</a></code></li>
<li><code><a title="gx_methods.get_lo_odu" href="#gx_methods.get_lo_odu">get_lo_odu</a></code></li>
<li><code><a title="gx_methods.delete_lo_odu" href="#gx_methods.delete_lo_odu">delete_lo_odu</a></code></li>
<li><code><a title="gx_methods.create_xcon" href="#gx_methods.create_xcon">create_xcon</a></code></li>
<li><code><a title="gx_methods.get_xcon" href="#gx_methods.get_xcon">get_xcon</a></code></li>
<li><code><a title="gx_methods.delete_xcon" href="#gx_methods.delete_xcon">delete_xcon</a></code></li>
<li><code><a title="gx_methods.update_chassis" href="#gx_methods.update_chassis">update_chassis</a></code></li>
<li><code><a title="gx_methods.get_chassis" href="#gx_methods.get_chassis">get_chassis</a></code></li>
<li><code><a title="gx_methods.update_system" href="#gx_methods.update_system">update_system</a></code></li>
<li><code><a title="gx_methods.get_system" href="#gx_methods.get_system">get_system</a></code></li>
<li><code><a title="gx_methods.update_clock" href="#gx_methods.update_clock">update_clock</a></code></li>
<li><code><a title="gx_methods.get_clock" href="#gx_methods.get_clock">get_clock</a></code></li>
<li><code><a title="gx_methods.create_aaa_radius" href="#gx_methods.create_aaa_radius">create_aaa_radius</a></code></li>
<li><code><a title="gx_methods.get_aaa_radius" href="#gx_methods.get_aaa_radius">get_aaa_radius</a></code></li>
<li><code><a title="gx_methods.delete_aaa_radius" href="#gx_methods.delete_aaa_radius">delete_aaa_radius</a></code></li>
<li><code><a title="gx_methods.create_aaa_tacacs" href="#gx_methods.create_aaa_tacacs">create_aaa_tacacs</a></code></li>
<li><code><a title="gx_methods.get_aaa_tacacs" href="#gx_methods.get_aaa_tacacs">get_aaa_tacacs</a></code></li>
<li><code><a title="gx_methods.delete_aaa_tacacs" href="#gx_methods.delete_aaa_tacacs">delete_aaa_tacacs</a></code></li>
<li><code><a title="gx_methods.update_ntp" href="#gx_methods.update_ntp">update_ntp</a></code></li>
<li><code><a title="gx_methods.get_ntp" href="#gx_methods.get_ntp">get_ntp</a></code></li>
<li><code><a title="gx_methods.create_ntp_key" href="#gx_methods.create_ntp_key">create_ntp_key</a></code></li>
<li><code><a title="gx_methods.get_ntp_key" href="#gx_methods.get_ntp_key">get_ntp_key</a></code></li>
<li><code><a title="gx_methods.delete_ntp_key" href="#gx_methods.delete_ntp_key">delete_ntp_key</a></code></li>
<li><code><a title="gx_methods.create_ntp_server" href="#gx_methods.create_ntp_server">create_ntp_server</a></code></li>
<li><code><a title="gx_methods.get_ntp_server" href="#gx_methods.get_ntp_server">get_ntp_server</a></code></li>
<li><code><a title="gx_methods.delete_ntp_server" href="#gx_methods.delete_ntp_server">delete_ntp_server</a></code></li>
<li><code><a title="gx_methods.update_grpc_server" href="#gx_methods.update_grpc_server">update_grpc_server</a></code></li>
<li><code><a title="gx_methods.get_grpc_server" href="#gx_methods.get_grpc_server">get_grpc_server</a></code></li>
<li><code><a title="gx_methods.create_dns" href="#gx_methods.create_dns">create_dns</a></code></li>
<li><code><a title="gx_methods.update_dns" href="#gx_methods.update_dns">update_dns</a></code></li>
<li><code><a title="gx_methods.get_dns" href="#gx_methods.get_dns">get_dns</a></code></li>
<li><code><a title="gx_methods.delete_dns" href="#gx_methods.delete_dns">delete_dns</a></code></li>
<li><code><a title="gx_methods.update_lldp" href="#gx_methods.update_lldp">update_lldp</a></code></li>
<li><code><a title="gx_methods.get_lldp" href="#gx_methods.get_lldp">get_lldp</a></code></li>
<li><code><a title="gx_methods.create_static_route" href="#gx_methods.create_static_route">create_static_route</a></code></li>
<li><code><a title="gx_methods.update_static_route" href="#gx_methods.update_static_route">update_static_route</a></code></li>
<li><code><a title="gx_methods.get_static_route" href="#gx_methods.get_static_route">get_static_route</a></code></li>
<li><code><a title="gx_methods.delete_static_route" href="#gx_methods.delete_static_route">delete_static_route</a></code></li>
<li><code><a title="gx_methods.create_static_route_dcn" href="#gx_methods.create_static_route_dcn">create_static_route_dcn</a></code></li>
<li><code><a title="gx_methods.update_static_route_dcn" href="#gx_methods.update_static_route_dcn">update_static_route_dcn</a></code></li>
<li><code><a title="gx_methods.get_static_route_dcn" href="#gx_methods.get_static_route_dcn">get_static_route_dcn</a></code></li>
<li><code><a title="gx_methods.delete_static_route_dcn" href="#gx_methods.delete_static_route_dcn">delete_static_route_dcn</a></code></li>
<li><code><a title="gx_methods.create_lo_mgmt" href="#gx_methods.create_lo_mgmt">create_lo_mgmt</a></code></li>
<li><code><a title="gx_methods.update_lo_mgmt" href="#gx_methods.update_lo_mgmt">update_lo_mgmt</a></code></li>
<li><code><a title="gx_methods.get_lo_mgmt" href="#gx_methods.get_lo_mgmt">get_lo_mgmt</a></code></li>
<li><code><a title="gx_methods.delete_lo_mgmt" href="#gx_methods.delete_lo_mgmt">delete_lo_mgmt</a></code></li>
<li><code><a title="gx_methods.update_interface" href="#gx_methods.update_interface">update_interface</a></code></li>
<li><code><a title="gx_methods.get_interface" href="#gx_methods.get_interface">get_interface</a></code></li>
<li><code><a title="gx_methods.update_ethernet_interface" href="#gx_methods.update_ethernet_interface">update_ethernet_interface</a></code></li>
<li><code><a title="gx_methods.get_ethernet_interface" href="#gx_methods.get_ethernet_interface">get_ethernet_interface</a></code></li>
<li><code><a title="gx_methods.update_aux_interface" href="#gx_methods.update_aux_interface">update_aux_interface</a></code></li>
<li><code><a title="gx_methods.get_aux_interface" href="#gx_methods.get_aux_interface">get_aux_interface</a></code></li>
<li><code><a title="gx_methods.update_dcn_interface" href="#gx_methods.update_dcn_interface">update_dcn_interface</a></code></li>
<li><code><a title="gx_methods.get_dcn_interface" href="#gx_methods.get_dcn_interface">get_dcn_interface</a></code></li>
<li><code><a title="gx_methods.update_craft_interface" href="#gx_methods.update_craft_interface">update_craft_interface</a></code></li>
<li><code><a title="gx_methods.get_craft_interface" href="#gx_methods.get_craft_interface">get_craft_interface</a></code></li>
<li><code><a title="gx_methods.create_dial_out_server" href="#gx_methods.create_dial_out_server">create_dial_out_server</a></code></li>
<li><code><a title="gx_methods.get_dial_out_server" href="#gx_methods.get_dial_out_server">get_dial_out_server</a></code></li>
<li><code><a title="gx_methods.delete_dial_out_server" href="#gx_methods.delete_dial_out_server">delete_dial_out_server</a></code></li>
<li><code><a title="gx_methods.create_user" href="#gx_methods.create_user">create_user</a></code></li>
<li><code><a title="gx_methods.update_user" href="#gx_methods.update_user">update_user</a></code></li>
<li><code><a title="gx_methods.get_user" href="#gx_methods.get_user">get_user</a></code></li>
<li><code><a title="gx_methods.delete_user" href="#gx_methods.delete_user">delete_user</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>